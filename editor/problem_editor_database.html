<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Math Problems Database Editor</title>
    <!-- Supabase JavaScript client -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <!-- MathJax for LaTeX rendering -->
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['\\(', '\\)'], ['$', '$']],
                displayMath: [['\\[', '\\]'], ['$$', '$$']],
                processEscapes: true,
                processEnvironments: true,
                packages: {'[+]': ['ams', 'html']}
            },
            options: {
                skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
            },
            loader: {
                load: ['[tex]/ams', '[tex]/html']
            }
        };
        
        // Preprocess LaTeX list environments and text commands to HTML
        function preprocessLatexLists(text) {
            if (!text) return text;
            
            // Protect LaTeX environments that should not have \\ converted to <br>
            // Store them temporarily and restore after processing
            const protectedEnvironments = [];
            const placeholder = '___PROTECTED_ENV_';
            
            // Protect cases environment and other math environments
            text = text.replace(/\\begin\{cases\}[\s\S]*?\\end\{cases\}/g, function(match) {
                const index = protectedEnvironments.length;
                protectedEnvironments.push(match);
                return placeholder + index + '___';
            });
            
            // Protect align, aligned, array environments (including starred versions)
            text = text.replace(/\\begin\{(align\*?|aligned|array|matrix|pmatrix|bmatrix|vmatrix|Vmatrix|gather\*?|equation\*?|eqnarray\*?|multline\*?|split|alignat\*?)\}[\s\S]*?\\end\{\1\}/g, function(match) {
                const index = protectedEnvironments.length;
                protectedEnvironments.push(match);
                return placeholder + index + '___';
            });
            
            // Convert itemize environment to HTML list
            text = text.replace(/\\begin\{itemize\}([\s\S]*?)\\end\{itemize\}/g, function(match, content) {
                // Process each \item
                const items = content.split(/\\item\s+/).filter(item => item.trim());
                if (items.length === 0) return match;
                
                const htmlItems = items.map(item => `<li>${item.trim()}</li>`).join('\n');
                return `<ul style="margin: 10px 0; padding-left: 20px;">\n${htmlItems}\n</ul>`;
            });
            
            // Convert enumerate environment to HTML list
            text = text.replace(/\\begin\{enumerate\}([\s\S]*?)\\end\{enumerate\}/g, function(match, content) {
                // Process each \item
                const items = content.split(/\\item\s+/).filter(item => item.trim());
                if (items.length === 0) return match;
                
                const htmlItems = items.map(item => `<li>${item.trim()}</li>`).join('\n');
                return `<ol style="margin: 10px 0; padding-left: 20px;">\n${htmlItems}\n</ol>`;
            });
            
            // Convert \underline{...} to HTML underline
            text = text.replace(/\\underline\{([^}]+)\}/g, '<u>$1</u>');
            
            // Convert \textbf{...} to HTML bold
            text = text.replace(/\\textbf\{([^}]+)\}/g, '<b>$1</b>');
            
            // Convert \dne to "Does Not Exist" (DNE)
            text = text.replace(/\\dne/g, 'DNE');
            
            // Convert \\ to line breaks (but not inside math expressions)
            text = text.replace(/\\\\(?![a-zA-Z])/g, '<br>');
            
            // Convert \par to paragraph breaks
            text = text.replace(/\\par\b/g, '<br><br>');
            
            // Convert image references ![filename] or ![filename|size] to HTML img tags
            text = text.replace(/!\[([^\|\]]+)(?:\|([^\]]+))?\]/g, function(match, filename, size) {
                // Get the current document ID for the image path
                const documentId = problemsData && problemsData.document ? problemsData.document.id : '';
                
                if (documentId && filename) {
                    const imageUrl = getSupabaseImageUrl(documentId, filename);
                    
                    // Parse size parameter
                    let imageStyle = 'max-width: 100%; max-height: 400px; height: auto;';
                    
                    if (size) {
                        if (size.includes('x')) {
                            // Format: widthxheight (e.g., "300x200")
                            const [width, height] = size.split('x');
                            imageStyle = `width: ${width}px; height: ${height}px;`;
                        } else if (size.includes('%')) {
                            // Percentage format (e.g., "50%")
                            imageStyle = `width: ${size}; height: auto;`;
                        } else {
                            // Single number = width in pixels (e.g., "300")
                            imageStyle = `width: ${size}px; height: auto;`;
                        }
                    }
                    
                    console.log(`Rendering image: ${filename} from URL: ${imageUrl} with style: ${imageStyle}`);
                    return `<div style="text-align: center; margin: 15px 0;">
                        <img src="${imageUrl}" alt="${filename}" style="${imageStyle} border: 1px solid #dee2e6; border-radius: 4px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);" 
                             onerror="console.error('Failed to load image:', '${imageUrl}'); this.style.display='none'; this.nextSibling.style.display='block';">
                        <div style="display: none; color: #666; font-style: italic; padding: 10px; border: 1px dashed #ccc; border-radius: 4px; background: #f8f9fa;">
                            Image not found: ${filename}<br>
                            <small>Path: ${imageUrl}</small>
                        </div>
                    </div>`;
                } else {
                    return `<div style="color: #666; font-style: italic; padding: 10px; border: 1px dashed #ccc; border-radius: 4px; margin: 10px 0; background: #f8f9fa; text-align: center;">Image not found: ${filename} (No document loaded)</div>`;
                }
            });
            
            // Restore protected environments
            protectedEnvironments.forEach((env, index) => {
                text = text.replace(placeholder + index + '___', env);
            });
            
            return text;
        }
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f5f5f5;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: white;
            color: #333;
            padding: 30px;
            text-align: center;
            border-bottom: 1px solid #e9ecef;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 0;
            font-weight: 300;
            color: #333;
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .controls {
            padding: 20px 30px;
            background: #f8f9fa;
            border-bottom: 1px solid #e9ecef;
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }

        .file-input {
            display: none;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.3s ease;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .btn-primary {
            background: #007bff;
            color: white;
        }

        .btn-primary:hover {
            background: #0056b3;
            transform: translateY(-2px);
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn-secondary:hover {
            background: #545b62;
            transform: translateY(-2px);
        }

        .btn-success {
            background: #28a745;
            color: white;
        }

        .btn-success:hover {
            background: #1e7e34;
            transform: translateY(-2px);
        }

        .btn-info {
            background: #17a2b8;
            color: white;
        }

        .btn-info:hover {
            background: #138496;
            transform: translateY(-2px);
        }

        .btn-warning {
            background: #ffc107;
            color: #212529;
        }

        .btn-warning:hover {
            background: #e0a800;
            transform: translateY(-2px);
        }

        .main-content {
            display: flex;
            min-height: 600px;
        }

        .sidebar {
            width: 300px;
            background: #f8f9fa;
            border-right: 1px solid #e9ecef;
            max-height: 600px;
            display: flex;
            flex-direction: column;
        }

        .problem-list {
            list-style: none;
            flex: 1;
            overflow-y: auto;
            padding: 0;
            margin: 0;
        }

        .add-problem-container {
            flex-shrink: 0;
            padding: 15px;
            background: #f8f9fa;
            border-top: 1px solid #e9ecef;
        }

        .add-problem-btn {
            width: 100%;
            padding: 12px 16px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            transition: all 0.2s ease;
        }

        .add-problem-btn:hover {
            background: #0056b3;
            transform: translateY(-1px);
        }

        .add-problem-btn:active {
            transform: translateY(0);
        }

        .add-problem-icon {
            font-size: 18px;
            font-weight: bold;
        }

        .add-problem-text {
            font-size: 14px;
        }

        .problem-item {
            padding: 15px 20px;
            border-bottom: 1px solid #e9ecef;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .problem-item:hover {
            background: #e9ecef;
        }

        .problem-item.active {
            background: #007bff;
            color: white;
        }

        .problem-id {
            font-weight: 500;
            font-size: 14px;
        }

        .problem-status {
            font-size: 12px;
            padding: 4px 8px;
            border-radius: 12px;
            background: #ffc107;
            color: #212529;
        }

        .problem-status.incomplete {
            background: #ffc107;
            color: #212529;
        }

        .problem-status.incomplete::before {
            content: "⚠";
            margin-right: 4px;
        }

        .problem-status.complete {
            background: #28a745;
            color: white;
        }

        .problem-status.complete::before {
            content: "✓";
            margin-right: 4px;
        }

        .editor-panel {
            flex: 1;
            padding: 30px;
            overflow-y: auto;
            max-height: 600px;
        }

        .form-group {
            margin-bottom: 25px;
        }

        .form-label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #495057;
            font-size: 14px;
        }

        .form-control {
            width: 100%;
            padding: 12px 15px;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s ease;
            font-family: inherit;
        }

        .form-control:focus {
            outline: none;
            border-color: #007bff;
            box-shadow: 0 0 0 3px rgba(0,123,255,0.1);
        }

        textarea.form-control {
            min-height: 120px;
            resize: vertical;
        }

        .problem-text-display {
            background: #f8f9fa;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            min-height: 100px;
        }

        .problem-text-display:hover {
            border-color: #007bff;
            background: #f0f8ff;
        }

        .problem-text-display.editing {
            border-color: #007bff;
            background: white;
        }

        .problem-text-display .edit-hint {
            font-size: 12px;
            color: #6c757d;
            margin-top: 10px;
            font-style: italic;
        }

        .problem-text-display .edit-hint::before {
            content: "Click to edit LaTeX";
        }

        .problem-text-display.editing .edit-hint::before {
            content: "Editing LaTeX - click outside to save";
        }

        .answer-option-display .edit-hint {
            font-size: 12px;
            color: #6c757d;
            margin-top: 10px;
            font-style: italic;
        }

        .answer-option-display .edit-hint::before {
            content: "Click to edit LaTeX";
        }

        .answer-option-display.editing .edit-hint::before {
            content: "Editing LaTeX - click outside to save";
        }

        .problem-image {
            margin: 15px 0;
            text-align: center;
        }

        .problem-image img {
            max-width: 100%;
            max-height: 300px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }

        .problem-image .no-image {
            color: #6c757d;
            font-style: italic;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
            border: 2px dashed #dee2e6;
        }

        .answer-options {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 10px;
        }

        .answer-option {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            background: white;
        }

        .answer-option input[type="text"] {
            flex: 1;
            border: none;
            outline: none;
            font-size: 14px;
        }

        .answer-option textarea {
            flex: 1;
            border: none;
            outline: none;
            font-size: 14px;
            resize: vertical;
            min-height: 60px;
            font-family: inherit;
        }

        .answer-option.selected {
            border-color: #28a745;
            background: #f8fff9;
        }

        .answer-option-label {
            font-weight: bold;
            min-width: 30px;
            text-align: center;
        }

        .answer-option-display {
            background: #f8f9fa;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            min-height: 80px;
        }

        .answer-option-display:hover {
            border-color: #007bff;
            background: #f0f8ff;
        }

        .answer-option-display.editing {
            border-color: #007bff;
            background: white;
        }

        .answer-option-display .edit-hint {
            font-size: 12px;
            color: #6c757d;
            margin-top: 10px;
            font-style: italic;
        }

        .answer-option-display .edit-hint::before {
            content: "Click to edit LaTeX";
        }

        .answer-option-display.editing .edit-hint::before {
            content: "Editing LaTeX - click outside to save";
        }

        .text-answer-container {
            margin-top: 15px;
        }

        .text-answer-container .form-label {
            margin-bottom: 10px;
        }

        .text-answer-container textarea {
            min-height: 80px;
            font-family: 'Courier New', monospace;
        }

        .difficulty-buttons {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .difficulty-btn {
            padding: 8px 16px;
            border: 2px solid #e9ecef;
            background: white;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 14px;
        }

        .difficulty-btn:hover {
            border-color: #007bff;
        }

        .difficulty-btn.selected {
            background: #007bff;
            color: white;
            border-color: #007bff;
        }

        .topics-container {
            margin-top: 10px;
        }

        .topics-search-container {
            position: relative;
            margin-bottom: 15px;
        }

        .topics-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 2px solid #007bff;
            border-top: 1px solid #007bff;
            border-radius: 0 0 8px 8px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 9999;
            box-shadow: 0 8px 16px rgba(0,0,0,0.15);
        }

        .topics-dropdown-item {
            padding: 10px 15px;
            cursor: pointer;
            border-bottom: 1px solid #f8f9fa;
            transition: background-color 0.2s ease;
        }

        .topics-dropdown-item:hover {
            background-color: #f8f9fa;
        }

        .topics-dropdown-item:last-child {
            border-bottom: none;
        }

        .topics-dropdown-item.selected {
            background-color: #e3f2fd;
            color: #1976d2;
        }

        .topics-list {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .topic-tag {
            background: #e9ecef;
            color: #495057;
            padding: 6px 12px;
            border-radius: 15px;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .topic-tag:hover {
            background: #dc3545;
            color: white;
        }

        .topic-tag .remove {
            font-weight: bold;
            font-size: 14px;
        }

        .subproblems-container {
            margin: 15px 0;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            background: #f8f9fa;
        }

        .subproblems-header {
            padding: 15px;
            background: #e9ecef;
            border-bottom: 1px solid #dee2e6;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: 600;
        }

        .subproblems-header:hover {
            background: #dee2e6;
        }

        .subproblems-toggle {
            font-size: 16px;
            transition: transform 0.3s ease;
        }

        .subproblems-toggle.expanded {
            transform: rotate(90deg);
        }

        .subproblems-content {
            padding: 15px;
            display: none;
        }

        .subproblems-content.expanded {
            display: block;
        }

        .subproblem-item {
            margin-bottom: 15px;
            padding: 15px;
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 6px;
        }

        .subproblem-label {
            font-weight: bold;
            color: #495057;
            margin-bottom: 8px;
            font-size: 14px;
        }


        .approach-container {
            margin-top: 10px;
        }

        .approach-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 10px;
        }

        .approach-btn {
            padding: 6px 12px;
            border: 2px solid #e9ecef;
            background: white;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 12px;
        }

        .approach-btn:hover {
            border-color: #007bff;
        }

        .approach-btn.selected {
            background: #007bff;
            color: white;
            border-color: #007bff;
        }

        .reasoning-container {
            margin-top: 10px;
        }

        .reasoning-input {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .reasoning-input input {
            flex: 1;
        }

        .reasoning-list {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .reasoning-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 10px;
        }

        .reasoning-btn {
            padding: 6px 12px;
            border: 2px solid #e9ecef;
            background: white;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 12px;
        }

        .reasoning-btn:hover {
            border-color: #007bff;
        }

        .reasoning-btn.selected {
            background: #007bff;
            color: white;
            border-color: #007bff;
        }

        .subproblem-controls {
            margin-top: 10px;
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .subproblem-add-input {
            width: 60px;
            padding: 6px 10px;
            border: 2px solid #e9ecef;
            border-radius: 4px;
            text-align: center;
            font-size: 14px;
        }

        .subproblem-controls button {
            padding: 6px 12px;
            font-size: 12px;
        }

        .subproblem-remove {
            float: right;
            background: #dc3545;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 4px 8px;
            cursor: pointer;
            font-size: 12px;
            margin-top: 5px;
        }

        .subproblem-remove:hover {
            background: #c82333;
        }

        .save-section {
            margin-top: 30px;
            padding-top: 20px;
            border-top: 2px solid #e9ecef;
            text-align: center;
        }

        .problem-id-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .remove-problem-btn {
            background: #dc3545;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 6px 12px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
        }

        .remove-problem-btn:hover {
            background: #c82333;
        }

        .stats {
            display: flex;
            gap: 20px;
            margin-top: 20px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
        }

        .stat-item {
            text-align: center;
        }

        .stat-number {
            font-size: 2rem;
            font-weight: bold;
            color: #007bff;
        }

        .stat-label {
            font-size: 12px;
            color: #6c757d;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .no-problem {
            text-align: center;
            padding: 60px 20px;
            color: #6c757d;
        }

        .no-problem h3 {
            margin-bottom: 10px;
            color: #495057;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #6c757d;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #007bff;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .error {
            background: #f8d7da;
            color: #721c24;
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
            border: 1px solid #f5c6cb;
        }

        .success {
            background: #d4edda;
            color: #155724;
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
            border: 1px solid #c3e6cb;
        }

        .image-remove-btn {
            position: absolute;
            top: 5px;
            right: 5px;
            background: #dc3545;
            color: white;
            border: none;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
            transition: all 0.2s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .image-remove-btn:hover {
            background: #c82333;
            transform: scale(1.1);
        }

        .image-item {
            position: relative;
        }

        .image-item:hover .image-remove-btn {
            opacity: 1;
        }

        @media (max-width: 768px) {
            .main-content {
                flex-direction: column;
            }
            
            .sidebar {
                width: 100%;
                max-height: 200px;
            }
            
            .controls {
                flex-direction: column;
                align-items: stretch;
            }
            
            .answer-options {
                grid-template-columns: 1fr;
            }
        }

        /* Modal styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.4);
            animation: fadeIn 0.3s;
        }

        @keyframes fadeIn {
            from {opacity: 0;}
            to {opacity: 1;}
        }

        .modal-content {
            background-color: #fefefe;
            margin: 5% auto;
            padding: 20px;
            border: none;
            border-radius: 8px;
            width: 80%;
            max-width: 600px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            animation: slideIn 0.3s;
        }

        @keyframes slideIn {
            from {transform: translateY(-50px); opacity: 0;}
            to {transform: translateY(0); opacity: 1;}
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 1px solid #e9ecef;
        }

        .modal-header h2 {
            color: #333;
            margin: 0;
        }

        .close {
            color: #aaa;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            transition: color 0.3s;
        }

        .close:hover {
            color: #000;
        }

        .document-list {
            max-height: 400px;
            overflow-y: auto;
            border: 1px solid #e9ecef;
            border-radius: 4px;
        }

        .document-item {
            padding: 15px 20px;
            border-bottom: 1px solid #e9ecef;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .document-item:last-child {
            border-bottom: none;
        }

        .document-item:hover {
            background-color: #f8f9fa;
        }

        .document-item.selected {
            background-color: #e3f2fd;
            border-left: 4px solid #2196f3;
        }

        .document-title {
            font-weight: 600;
            color: #333;
            margin-bottom: 5px;
        }

        .document-details {
            font-size: 14px;
            color: #666;
        }

        .modal-footer {
            margin-top: 20px;
            text-align: right;
        }

        .modal-footer .btn {
            margin-left: 10px;
        }

        /* Topic dropdown styles */
        .topic-dropdown {
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }

        .topic-option {
            padding: 10px 15px;
            cursor: pointer;
            transition: background-color 0.2s;
            border-bottom: 1px solid #f0f0f0;
        }

        .topic-option:last-child {
            border-bottom: none;
        }

        .topic-option:hover {
            background-color: #f8f9fa;
        }

        .topic-option.selected {
            background-color: #e3f2fd;
            color: #1976d2;
        }

        .topic-option-id {
            font-size: 11px;
            color: #999;
            margin-right: 8px;
        }

        .add-problem-btn {
            position: sticky;
            bottom: 0;
            background: #28a745;
            color: white;
            border: none;
            padding: 15px 20px;
            width: 100%;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.3s ease;
            border-top: 1px solid #e9ecef;
        }

        .add-problem-btn:hover {
            background: #218838;
        }

        .new-problem-highlight {
            background: #fff3cd !important;
            border-left: 4px solid #ffc107 !important;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Math Problems Database Editor</h1>
        </div>

        <div class="controls">
            <input type="file" id="fileInput" class="file-input" accept=".json">
            <button class="btn btn-primary" onclick="document.getElementById('fileInput').click()">
                📁 Load JSON File
            </button>
            <button class="btn btn-success" onclick="exportData()">
                💾 Export JSON
            </button>
            <button class="btn btn-info" onclick="showReadDatabaseModal()">
                📖 Read Database
            </button>
            <button class="btn btn-primary" onclick="updateDatabaseWorking()">
                🗃️ Update Database
            </button>
            <div id="fileInfo" style="margin-left: auto; color: #6c757d; font-size: 14px;"></div>
        </div>

        <div class="main-content">
            <div class="sidebar">
                <div id="problemList" class="problem-list">
                    <div class="no-problem" style="padding: 40px 20px; text-align: center; color: #6c757d;">
                        <h3 style="margin-bottom: 10px; color: #495057;">No File Loaded</h3>
                        <p>Load a JSON file to start editing</p>
                    </div>
                </div>
                <div class="add-problem-container">
                    <button class="add-problem-btn" onclick="addNewProblem()" title="Add New Problem">
                        <span class="add-problem-icon">+</span>
                        <span class="add-problem-text">Add Problem</span>
                    </button>
                </div>
            </div>

            <div class="editor-panel">
                <div id="noProblem" class="no-problem">
                    <h3>No Problem Selected</h3>
                    <p>Select a problem from the sidebar to start editing</p>
                </div>
            </div>
        </div>

        <div class="stats" id="stats" style="display: none;">
            <div class="stat-item">
                <div class="stat-number" id="totalProblems">0</div>
                <div class="stat-label">Total Problems</div>
            </div>
            <div class="stat-item">
                <div class="stat-number" id="completedProblems">0</div>
                <div class="stat-label">Completed</div>
            </div>
            <div class="stat-item">
                <div class="stat-number" id="incompleteProblems">0</div>
                <div class="stat-label">Incomplete</div>
            </div>
        </div>
    </div>

    <!-- Read Database Modal -->
    <div id="readDatabaseModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>📖 Load from Database</h2>
                <span class="close" onclick="closeReadDatabaseModal()">&times;</span>
            </div>
            
            <!-- Filter Options -->
            <div style="margin-bottom: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px;">
                <label style="font-weight: 600; margin-bottom: 10px; display: block;">Filter by:</label>
                <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                    <button id="filterDocumentBtn" class="btn btn-primary" onclick="setFilterMode('document')" style="font-size: 14px;">
                        📄 By Document
                    </button>
                    <button id="filterTopicBtn" class="btn btn-secondary" onclick="setFilterMode('topic')" style="font-size: 14px;">
                        🏷️ By Topic
                    </button>
                </div>
                
                <!-- Topic Selector (hidden by default) -->
                <div id="topicSelector" style="display: none; margin-top: 10px;">
                    <div style="position: relative;">
                        <input type="text" id="modalTopicSearchInput" class="form-control" placeholder="Search topics..." 
                               style="padding: 8px 35px 8px 8px; border: 1px solid #ccc; border-radius: 4px; width: 100%;"
                               oninput="filterTopicsInModal()" onfocus="showModalTopicDropdown()" onblur="hideModalTopicDropdown()">
                        <div style="position: absolute; right: 10px; top: 50%; transform: translateY(-50%); color: #666; pointer-events: none;">
                            🔍
                        </div>
                        <div id="modalTopicDropdown" class="topic-dropdown" style="display: none; position: absolute; top: 100%; left: 0; right: 0; background: white; border: 1px solid #ccc; border-top: none; border-radius: 0 0 4px 4px; max-height: 200px; overflow-y: auto; z-index: 1000;">
                        </div>
                    </div>
                    <div id="selectedTopicDisplay" style="margin-top: 8px; font-size: 12px; color: #666;"></div>
                </div>
            </div>
            
            <div id="documentListContainer">
                <div style="text-align: center; padding: 20px; color: #666;">
                    Loading documents...
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closeReadDatabaseModal()">Cancel</button>
                <button id="loadDocumentBtn" class="btn btn-primary" onclick="loadSelectedItem()" disabled>Load Problems</button>
            </div>
        </div>
    </div>

    <script>
        let problemsData = null;
        let currentProblemIndex = -1;
        let originalData = null;
        let imageBasePath = '';
        
        // Supabase configuration
        const SUPABASE_URL = 'https://sionddqweckwednamaeb.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InNpb25kZHF3ZWNrd2VkbmFtYWViIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTQ4NzI3MTksImV4cCI6MjA3MDQ0ODcxOX0.0I2jrSoxPBqwe_3isQUVORW6kSEqT3vwlQemoQXCpUw';
        const STORAGE_BUCKET = 'math-problems';
        const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
        let currentFileName = '';
        let originalFileName = '';
        let availableTopics = [];
        let dataSourceType = 'json'; // Track data source: 'json' or 'database'
        
        // ===== PASSWORD PROTECTION =====
        let isAuthorized = false;
        const ADMIN_PASSWORD_HASH = 'dXBlbm4yMDI1'; // "upenn2025" in base64

        function checkAdminPassword() {
            if (isAuthorized) {
                return true; // Already authorized in this session
            }
            
            const password = prompt('🔐 Enter admin password to update database:');
            if (!password) {
                return false; // User cancelled
            }
            
            const hashedPassword = btoa(password); // Simple base64 encoding
            
            if (hashedPassword === ADMIN_PASSWORD_HASH) {
                isAuthorized = true;
                updateAuthStatus();
                showSuccess('✅ Authorized for database updates');
                return true;
            }
            
            showError('❌ Invalid password. Database updates not allowed.');
            return false;
        }

        function resetAuthorization() {
            isAuthorized = false;
            updateAuthStatus();
            showSuccess('🔓 Authorization reset. Will prompt for password on next update.');
        }

        function updateAuthStatus() {
            const fileInfo = document.getElementById('fileInfo');
            if (isAuthorized) {
                fileInfo.innerHTML += ' <span style="color: #28a745; font-weight: bold;">🔓 ADMIN</span>';
            } else {
                // Remove admin status if present
                fileInfo.innerHTML = fileInfo.innerHTML.replace(/ <span style="color: #28a745; font-weight: bold;">🔓 ADMIN<\/span>/, '');
            }
        }

        // ===== WORKING DATABASE FUNCTIONS (using Supabase client directly) =====
        // These override the broken proxy-based functions below
        
        async function insertDocumentWorking(documentData) {
            const payload = {
                document_id: documentData.id,
                school: documentData.school || null,
                course: documentData.course || null,
                problem_type: documentData.problem_type || null,
                term: documentData.term || null,
                year: documentData.year ? parseInt(documentData.year) : null,
                total_problems: documentData.total_problems || 0
            };
            
            const { data, error } = await supabase
                .from('documents')
                .upsert(payload, { onConflict: 'document_id' })
                .select();
            
            if (error) throw new Error(`Document insert failed: ${error.message}`);
            return { data };
        }
        
        async function insertProblemWorking(problem, documentUuid) {
            // Get topic_id from topics array (expecting single value now)
            let topicId = null;
            if (problem.topics && problem.topics.length > 0) {
                topicId = problem.topics[0]; // Take first topic ID
            }
            
            const payload = {
                problem_id: problem.id,
                document_id: documentUuid,
                problem_text: problem.problem_text || null,
                correct_answer: problem.correct_answer || null,
                hint: problem.hint || null,
                solution_text: problem.solution && problem.solution.text ? problem.solution.text : null,
                math_approach: problem.math_approach || null,
                reasoning_type: problem.reasoning_type || null,
                topic_id: topicId,
                difficulty: problem.difficulty || null,
                importance: problem.importance || null,
                comment: problem.comment || null,
                version: problem.version || 'v1'
            };
            
            const { data, error } = await supabase
                .from('problems')
                .upsert(payload, { onConflict: 'problem_id' })
                .select();
            
            if (error) throw new Error(`Problem insert failed: ${error.message}`);
            return { data };
        }

        async function insertSubproblemsWorking(subproblems, problemUuid) {
            const subproblemData = [];
            for (const [key, subproblem] of Object.entries(subproblems)) {
                subproblemData.push({
                    problem_id: problemUuid,
                    key: key,
                    problem_text: subproblem.problem_text || null,
                    correct_answer: subproblem.correct_answer || null,
                    hint: subproblem.hint || null,
                    solution_text: subproblem.solution && subproblem.solution.text ? subproblem.solution.text : null,
                    comment: subproblem.comment || null
                });
            }
            
            if (subproblemData.length > 0) {
                const { data, error } = await supabase
                    .from('subproblems')
                    .upsert(subproblemData, { onConflict: 'problem_id,key' })
                    .select();
                
                if (error) throw new Error(`Subproblems insert failed: ${error.message}`);
                return { data };
            }
            return { data: [] };
        }


        // Images are handled directly via Supabase storage URLs from JSON data
        // No database insertion function needed for image metadata

        // Hints are now stored directly in problems/subproblems table - no separate function needed

        // Solutions are now stored directly in problems/subproblems table - no separate function needed

        // Topics are now stored directly as foreign key in problems table - no separate function needed

        // Approaches are now stored directly in problems table - no separate function needed

        // Reasoning types are now stored directly in problems table - no separate function needed

        // Override the main updateDatabase function to use working functions
        async function updateDatabaseWorking() {
            if (!problemsData) {
                showError('No data to update. Please load a JSON file first.');
                return;
            }
            
            // Check admin password before proceeding
            if (!checkAdminPassword()) {
                return;
            }
            
            try {
                const originalButton = event.target;
                const originalText = originalButton.innerHTML;
                originalButton.innerHTML = '⏳ Updating Database...';
                originalButton.disabled = true;
                console.log('Starting database update...');
                
                // Handle differently based on data source
                let problemsToUpdate = [];
                
                if (dataSourceType === 'json') {
                    // For JSON files: Upload ALL problems regardless of changes
                    problemsToUpdate = problemsData.problems.map((problem, index) => ({
                        index: index,
                        problemId: problem.id
                    }));
                    console.log(`Processing all ${problemsToUpdate.length} problems from JSON file`);
                } else {
                    // For database-loaded data: Only update changed problems
                    const changedProblems = detectChangedProblems();
                    
                    if (changedProblems.length === 0) {
                        // No changes detected
                        originalButton.innerHTML = originalText;
                        originalButton.disabled = false;
                        showSuccess('No changes detected. Database is up to date.');
                        return;
                    }
                    
                    problemsToUpdate = changedProblems;
                    console.log(`Found ${problemsToUpdate.length} changed problems:`, problemsToUpdate.map(cp => cp.problemId));
                }
                
                // Handle document creation/lookup based on data source
                let documentUuid;
                
                if (dataSourceType === 'json') {
                    // For JSON files: Create document first (or get existing one)
                    console.log('Ensuring document exists in database...');
                    const documentResult = await insertDocumentWorking(problemsData.document);
                    if (documentResult.data && documentResult.data.length > 0) {
                        documentUuid = documentResult.data[0].id;
                        console.log(`Document created/updated: ${problemsData.document.id} -> ${documentUuid}`);
                    } else {
                        throw new Error('Failed to create/update document in database');
                    }
                } else {
                    // For database-loaded data: Document should already exist
                    const { data: docData, error: docError } = await supabase
                        .from('documents')
                        .select('id')
                        .eq('document_id', problemsData.document.id)
                        .single();

                    if (docError) {
                        throw new Error('Failed to find document in database: ' + docError.message);
                    }
                    documentUuid = docData.id;
                }
                
                // Update problems based on source type
                let successfulUpdates = 0;
                
                for (const changeInfo of problemsToUpdate) {
                    try {
                        const problem = problemsData.problems[changeInfo.index];
                        const originalProblem = originalData.problems.find(p => p.id === problem.id);
                        
                        console.log(`Updating problem: ${problem.id}`);
                        
                        // Increment version
                        const newVersion = incrementVersion(originalProblem?.version || 'v1');
                        problem.version = newVersion;
                        problem.updated_at = new Date().toISOString();
                        
                        if (dataSourceType === 'json') {
                            // For JSON files: Insert new problems using the insertProblemWorking function
                            console.log(`Inserting new problem: ${problem.id}`);
                            await insertProblemWorking(problem, documentUuid);
                        } else {
                            // For database data: Update existing problems
                            const updateData = {
                                problem_text: problem.problem_text,
                                correct_answer: problem.correct_answer,
                                hint: problem.hint,
                                solution_text: problem.solution?.text,
                                math_approach: problem.math_approach,
                                reasoning_type: problem.reasoning_type,
                                topic_id: problem.topics && problem.topics.length > 0 ? problem.topics[0] : null,
                                difficulty: problem.difficulty,
                                importance: problem.importance,
                                comment: problem.comment,
                                version: newVersion,
                                updated_at: new Date().toISOString()
                            };
                            
                            const { error: updateError } = await supabase
                                .from('problems')
                                .update(updateData)
                                .eq('problem_id', problem.id);
                            
                            if (updateError) {
                                throw updateError;
                            }
                        }
                        
                        // Update subproblems if they exist
                        if (problem.subproblems && Object.keys(problem.subproblems).length > 0) {
                            // Get the problem UUID from database
                            const { data: problemData, error: problemError } = await supabase
                                .from('problems')
                                .select('id')
                                .eq('problem_id', problem.id)
                                .single();
                                
                            if (!problemError) {
                                const problemUuid = problemData.id;
                                
                                // Delete existing subproblems and insert new ones (simpler than selective update)
                                await supabase.from('subproblems').delete().eq('problem_id', problemUuid);
                                await insertSubproblemsWorking(problem.subproblems, problemUuid);
                            }
                        }
                        
                        successfulUpdates++;
                        console.log(`Problem ${problem.id} updated successfully to version ${newVersion}`);
                        
                    } catch (problemError) {
                        console.error(`Failed to update problem ${changeInfo.problemId}:`, problemError);
                    }
                }
                
                // Update originalData to reflect the new state
                if (successfulUpdates > 0) {
                    originalData = JSON.parse(JSON.stringify(problemsData));
                    
                    // Save to localStorage
                    localStorage.setItem('problemsData', JSON.stringify(problemsData));
                }
                
                // Reset button
                originalButton.innerHTML = originalText;
                originalButton.disabled = false;
                
                if (successfulUpdates === problemsToUpdate.length) {
                    const sourceMessage = dataSourceType === 'json' ? 'All problems from JSON file' : 'Changed problems';
                    showSuccess(`Database update completed! ${sourceMessage}: ${successfulUpdates} problem(s) updated successfully.`);
                } else {
                    showError(`Partial update: ${successfulUpdates}/${problemsToUpdate.length} problem(s) updated successfully.`);
                }
                console.log('Database update completed');
                
            } catch (error) {
                console.error('Database update failed:', error);
                showError(`Database update failed: ${error.message}`);
                
                // Reset button on error
                if (event && event.target) {
                    event.target.innerHTML = '🗃️ Update Database';
                    event.target.disabled = false;
                }
            }
        }

        // Load topics data - embedded to avoid fetch issues
        function loadTopics() {
            availableTopics = [
                {"id": 1, "name": "Variables, Functions and Graphs"},
                {"id": 2, "name": "Limits of Functions"},
                {"id": 3, "name": "Continuity and IVT"},
                {"id": 4, "name": "Indeterminate Forms Limits via Algebraic Manipulation"},
                {"id": 5, "name": "Limits at Infinity and Asymptotes"},
                {"id": 6, "name": "Limiting Definition of Derivatives"},
                {"id": 7, "name": "Chain, Product and Quotient Rules"},
                {"id": 8, "name": "Implicit Differentiation and Inverse Derivatives"},
                {"id": 9, "name": "Logarithmic Differentiation"},
                {"id": 10, "name": "Inverse Trig and Hyperbolic Functions"},
                {"id": 11, "name": "Indeterminate Forms Limits via L'Hospital Rule"},
                {"id": 12, "name": "Extreme Values, Monotonicity and Concavity"},
                {"id": 13, "name": "Applied Optimization"},
                {"id": 14, "name": "Approximation via Differentiation"},
                {"id": 15, "name": "Antiderivatives"},
                {"id": 16, "name": "Riemann Sum and Definite Integral"},
                {"id": 17, "name": "Fundamental Theorem of Calculus"},
                {"id": 18, "name": "Substitution Rules"},
                {"id": 19, "name": "Area Between Curves"},
                {"id": 20, "name": "Volume by Slicing"},
                {"id": 21, "name": "Volume by Cylindrical Shells"},
                {"id": 22, "name": "Integration by Parts"},
                {"id": 23, "name": "Partial Fractions"},
                {"id": 24, "name": "Improper Integrals"},
                {"id": 25, "name": "Arc Length"},
                {"id": 26, "name": "Surface Area"},
                {"id": 27, "name": "Sequences"},
                {"id": 28, "name": "Series"},
                {"id": 29, "name": "Integral Tests"},
                {"id": 30, "name": "Comparison Tests"},
                {"id": 31, "name": "Alternating Series"},
                {"id": 32, "name": "Absolute Convergence, Ratio and Root Test"},
                {"id": 33, "name": "Power Series"},
                {"id": 34, "name": "Taylor and MacLaurin Series"},
                {"id": 35, "name": "Applications of Taylor Polynomials"},
                {"id": 36, "name": "Separable and Homogeneous ODE"},
                {"id": 37, "name": "First Order Linear ODE"},
                {"id": 38, "name": "Second Order Linear ODE"},
                {"id": 39, "name": "Nonhomogeneous Linear ODE"},
                {"id": 40, "name": "Series Solutions of ODE"}
            ];
            console.log('Topics loaded:', availableTopics.length);
        }

        // File input handling
        document.getElementById('fileInput').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        problemsData = JSON.parse(e.target.result);
                        originalData = JSON.parse(e.target.result);
                        dataSourceType = 'json'; // Mark as JSON file source
                        loadProblems();
                        currentFileName = file.name.replace('.json', '');
                        originalFileName = file.name;
                        document.getElementById('fileInfo').textContent = `Loaded: ${file.name}`;
                    } catch (error) {
                        showError('Invalid JSON file. Please check the file format.');
                    }
                };
                reader.readAsText(file);
            }
        });

        function loadProblems() {
            if (!problemsData || !problemsData.problems) {
                showError('Invalid data format. Expected a JSON object with a "problems" array.');
                return;
            }

            const problemList = document.getElementById('problemList');
            problemList.innerHTML = '';

            try {
                console.log(`Loading ${problemsData.problems.length} problems`);
                problemsData.problems.forEach((problem, index) => {
                    console.log(`Processing problem ${index + 1}: ${problem.id}`);
                    // Initialize null fields to prevent errors
                    if (!problem.topics) problem.topics = [];
                    if (!problem.hint) problem.hint = null;
                    if (!problem.solution) problem.solution = { text: null, images: [] };
                    if (problem.solution && !problem.solution.text) problem.solution.text = null;
                    if (problem.solution && !problem.solution.images) problem.solution.images = [];
                    if (!problem.subproblems) problem.subproblems = {};
                    if (!problem.math_approach) problem.math_approach = null;
                    if (!problem.reasoning_type) problem.reasoning_type = null;
                    if (!problem.images) problem.images = [];
                    
                    
                    // Convert topic names to IDs if needed
                    if (problem.topics && Array.isArray(problem.topics)) {
                        problem.topics = problem.topics.map(topic => {
                            if (typeof topic === 'string') {
                                // Find topic by name and convert to ID
                                const foundTopic = availableTopics.find(t => t.name === topic);
                                return foundTopic ? foundTopic.id : topic;
                            }
                            return topic; // Already an ID
                        });
                    }
                    
                    const isComplete = isProblemComplete(problem);
                    const listItem = document.createElement('div');
                    listItem.className = 'problem-item';
                    listItem.onclick = () => selectProblem(index);
                    
                    listItem.innerHTML = `
                        <div class="problem-id">${problem.id}</div>
                        <div class="problem-status ${isComplete ? 'complete' : 'incomplete'}">
                        </div>
                    `;
                    
                    problemList.appendChild(listItem);
                });

                updateStats();
                selectProblem(0);
            } catch (error) {
                console.error('Error loading problems:', error);
                showError('Error loading problems. Check console for details.');
            }
        }

        function selectProblem(index) {
            if (index < 0 || index >= problemsData.problems.length) return;

            // Remove active class from all items
            document.querySelectorAll('.problem-item').forEach(item => {
                item.classList.remove('active');
            });

            // Add active class to selected item
            document.querySelectorAll('.problem-item')[index].classList.add('active');

            currentProblemIndex = index;
            const problem = problemsData.problems[index];
            console.log(`selectProblem: index=${index}, problem=`, problem);
            displayProblem(problem);
            
            // Scroll to top of editor panel
            const editorPanel = document.querySelector('.editor-panel');
            if (editorPanel) {
                editorPanel.scrollTop = 0;
            }
        }

        function addNewProblem() {
            if (!problemsData) {
                showError('No document loaded. Please load a JSON file first.');
                return;
            }

            // Generate a unique problem ID
            let newProblemId = '';
            let counter = 1;
            do {
                newProblemId = `new_problem_${counter}`;
                counter++;
            } while (problemsData.problems.some(p => p.id === newProblemId));

            // Create new problem template
            const newProblem = {
                id: newProblemId,
                problem_text: '',
                answer_options: null,
                correct_answer: '',
                solution: { text: '', images: [] },
                hint: '',
                images: [],
                difficulty: '',
                topics: [],
                math_approach: null,
                reasoning_type: null,
                comment: '',
                importance: 1,
                subproblems: {}
            };

            // Add the new problem to the problems array
            problemsData.problems.push(newProblem);

            // Sort problems numerically by problem number suffix
            problemsData.problems.sort((a, b) => {
                // Extract the problem number from the end of the ID (e.g., "p1", "p10", "p2")
                const getNumber = (id) => {
                    const match = id.match(/_p(\d+)$/);
                    return match ? parseInt(match[1]) : 0;
                };
                return getNumber(a.id) - getNumber(b.id);
            });

            // Find the index of the new problem after sorting
            const newIndex = problemsData.problems.findIndex(p => p.id === newProblemId);

            // Update display
            displayProblemsList();
            selectProblem(newIndex);

            // Focus on the problem ID input for new problems
            setTimeout(() => {
                const problemIdInput = document.querySelector('.problem-id-input');
                if (problemIdInput && !problemIdInput.readOnly) {
                    problemIdInput.focus();
                    problemIdInput.select();
                }
            }, 100);

            // Save to localStorage
            localStorage.setItem('problemsData', JSON.stringify(problemsData));
            
            // Show success message
            showSuccess('New problem added successfully!');
        }

        function updateProblemId(newId) {
            if (!newId.trim()) {
                showError('Problem ID cannot be empty');
                return;
            }

            // Check if ID already exists
            if (problemsData.problems.some((p, index) => p.id === newId && index !== currentProblemIndex)) {
                showError('Problem ID already exists');
                return;
            }

            // Update the problem ID
            const oldId = problemsData.problems[currentProblemIndex].id;
            problemsData.problems[currentProblemIndex].id = newId;

            // Sort problems numerically by problem number suffix
            problemsData.problems.sort((a, b) => {
                // Extract the problem number from the end of the ID (e.g., "p1", "p10", "p2")
                const getNumber = (id) => {
                    const match = id.match(/_p(\d+)$/);
                    return match ? parseInt(match[1]) : 0;
                };
                return getNumber(a.id) - getNumber(b.id);
            });

            // Find new index after sorting
            const newIndex = problemsData.problems.findIndex(p => p.id === newId);

            // Update display
            displayProblemsList();
            selectProblem(newIndex);

            // Make the input readonly now that it's been set
            const inputElement = document.querySelector('.problem-id-input');
            if (inputElement && !newId.startsWith('new_problem_')) {
                inputElement.setAttribute('readonly', 'true');
            }

            // Save to localStorage
            localStorage.setItem('problemsData', JSON.stringify(problemsData));
            
            showSuccess('Problem ID updated successfully!');
        }

        function displayProblem(problem) {
            const editorPanel = document.querySelector('.editor-panel');
            const isTextAnswer = !problem.answer_options;
            
            editorPanel.innerHTML = `
                <div class="form-group">
                    <label class="form-label">Problem ID</label>
                    <div class="problem-id-container">
                        <input type="text" class="form-control problem-id-input" value="${problem.id}" ${problem.id.startsWith('new_problem_') ? '' : 'readonly'} onchange="updateProblemId(this.value)" style="flex: 1;">
                        <button class="remove-problem-btn" onclick="removeProblem()">Remove Problem</button>
                    </div>
                </div>

                <div class="form-group">
                    <label class="form-label">Problem Text</label>
                    <div class="problem-text-display" onclick="toggleProblemTextEdit()" id="problemTextDisplay">
                        <div id="problemTextRendered">${preprocessLatexLists(problem.problem_text || '')}</div>
                    </div>
                    <div class="answer-option" id="problemTextEdit" style="display: none;">
                        <textarea id="problemTextTextarea" onchange="updateProblem('problem_text', this.value)" onblur="saveProblemText()" onkeydown="handleMultilineEdit(event)" placeholder="Enter problem text...">${problem.problem_text || ''}</textarea>
                    </div>
                </div>

                ${problem.images && problem.images.length > 0 ? `
                <div class="form-group">
                    <label class="form-label">Images</label>
                    <div class="problem-image" id="problemImage">
                        ${generateProblemImage(problem.images)}
                    </div>
                </div>
                ` : ''}

                ${generateSubproblemsSection(problem.subproblems)}

                <div class="form-group">
                    <label class="form-label">Hint</label>
                    <div id="hintsContainer">
                        ${generateHintSection(problem.hint || null)}
                    </div>
                </div>

                <div class="form-group">
                    <label class="form-label">Solution</label>
                    <div id="solutionsContainer">
                        ${generateSolutionSection(problem.solution)}
                    </div>
                    ${problem.solution && problem.solution.images && problem.solution.images.length > 0 ? `
                    <div class="form-group" style="margin-top: 15px;">
                        <label class="form-label" style="font-size: 12px;">Solution Images</label>
                        <div class="problem-image">
                            ${generateImageSection(problem.solution.images, 'problem_solution')}
                        </div>
                    </div>
                    ` : ''}
                </div>

                ${isTextAnswer ? `
                    <div class="form-group">
                        <label class="form-label">Correct Answer</label>
                        <div class="problem-text-display" onclick="toggleTextAnswerEdit()" id="textAnswerDisplay">
                            <div id="textAnswerRendered">${preprocessLatexLists(problem.correct_answer || '')}</div>
                        </div>
                        <div class="answer-option" id="textAnswerEdit" style="display: none;">
                            <textarea onchange="updateProblem('correct_answer', this.value)" onblur="saveTextAnswer()" onkeydown="handleMultilineEdit(event)" placeholder="Enter the answer...">${problem.correct_answer || ''}</textarea>
                        </div>
                    </div>
                ` : `
                    <div class="form-group">
                        <label class="form-label">Answer Options</label>
                        <div class="answer-options" id="answerOptions">
                            ${generateAnswerOptions(problem.answer_options)}
                        </div>
                    </div>

                    <div class="form-group">
                        <label class="form-label">Correct Answer</label>
                        <select class="form-control" id="correctAnswer" onchange="updateProblem('correct_answer', this.value)">
                            <option value="">Select correct answer...</option>
                            ${generateCorrectAnswerOptions(problem.answer_options)}
                        </select>
                    </div>
                `}

                <div class="form-group">
                    <label class="form-label">Difficulty Level</label>
                    <div class="difficulty-buttons">
                        <button class="difficulty-btn ${problem.difficulty === 'easy' ? 'selected' : ''}" onclick="setDifficulty('easy')">Easy</button>
                        <button class="difficulty-btn ${problem.difficulty === 'medium' ? 'selected' : ''}" onclick="setDifficulty('medium')">Medium</button>
                        <button class="difficulty-btn ${problem.difficulty === 'hard' ? 'selected' : ''}" onclick="setDifficulty('hard')">Hard</button>
                        <button class="difficulty-btn ${problem.difficulty === 'very_hard' ? 'selected' : ''}" onclick="setDifficulty('very_hard')">Very Hard</button>
                    </div>
                </div>


                <div class="form-group">
                    <label class="form-label">Topics</label>
                    <div class="topics-container">
                        <div class="topics-search-container" style="position: relative;">
                            <input type="text" class="form-control" id="topicSearchInput" placeholder="Search topics..." oninput="handleTopicInput()" onfocus="showTopicsDropdown()" onblur="hideTopicsDropdown()">
                            <button type="button" style="position: absolute; right: 5px; top: 5px; background: #007bff; color: white; border: none; border-radius: 4px; padding: 5px 10px; cursor: pointer; z-index: 10;" onclick="testTopicsDropdown()">▼</button>
                            <div id="topicsDropdown" class="topics-dropdown" style="display: none;">
                                <!-- Topics will be populated here -->
                            </div>
                        </div>
                        <div class="topics-list" id="topicsList">
                            ${generateTopicsList(problem.topics || [])}
                        </div>
                    </div>
                </div>

                <div class="form-group">
                    <label class="form-label">Mathematical Approach</label>
                    <div class="approach-container">
                        <div class="approach-buttons" id="approachButtons">
                            ${generateApproachButtons(problem.math_approach || null)}
                        </div>
                    </div>
                </div>

                <div class="form-group">
                    <label class="form-label">Type of Reasoning</label>
                    <div class="reasoning-buttons">
                        ${generateReasoningButtons(problem.reasoning_type || null)}
                    </div>
                </div>

                <div class="form-group">
                    <label class="form-label">Comment</label>
                    <div class="problem-text-display" onclick="toggleCommentEdit()" id="commentDisplay">
                        <div id="commentRendered">${preprocessLatexLists(problem.comment || '')}</div>
                    </div>
                    <div class="answer-option" id="commentEdit" style="display: none;">
                        <textarea id="commentTextarea" onchange="updateProblem('comment', this.value)" onblur="saveComment()" onkeydown="handleMultilineEdit(event)" placeholder="Enter comment...">${problem.comment || ''}</textarea>
                    </div>
                </div>

                <div class="form-group">
                    <label class="form-label">Importance</label>
                    <select class="form-control" id="importanceSelect" onchange="updateProblem('importance', parseInt(this.value))">
                        <option value="">Select importance...</option>
                        <option value="1" ${problem.importance === 1 ? 'selected' : ''}>1</option>
                        <option value="2" ${problem.importance === 2 ? 'selected' : ''}>2</option>
                        <option value="3" ${problem.importance === 3 ? 'selected' : ''}>3</option>
                    </select>
                </div>

                <div class="save-section">
                    <button class="btn btn-success" onclick="saveCurrentProblem()">
                        💾 Save Problem
                    </button>
                </div>
            `;

            // Set correct answer if it exists
            if (problem.correct_answer && !isTextAnswer) {
                document.getElementById('correctAnswer').value = problem.correct_answer;
            }

            // Render LaTeX for problem text, answer options, solution, text answer, and subproblems
            if (window.MathJax) {
                const elementsToRender = [];
                
                // Add problem text element
                const problemTextElement = document.getElementById('problemTextRendered');
                if (problemTextElement) elementsToRender.push(problemTextElement);
                
                // Add text answer element if it exists
                if (isTextAnswer) {
                    const textAnswerElement = document.getElementById('textAnswerRendered');
                    if (textAnswerElement) elementsToRender.push(textAnswerElement);
                }
                
                // Add solution elements (now multiple)
                let solutions = [];
                if (problem.solution) {
                    if (typeof problem.solution === 'string') {
                        solutions = [problem.solution];
                    } else if (problem.solution.text) {
                        solutions = Array.isArray(problem.solution.text) ? problem.solution.text : [problem.solution.text];
                    }
                }
                // Add single solution element
                if (problem.solution && problem.solution.text) {
                    const elem = document.getElementById(`solutionRendered_single`);
                    if (elem) elementsToRender.push(elem);
                }
                
                // Add hint element (single)
                if (problem.hint) {
                    const elem = document.getElementById(`hintRendered_single`);
                    if (elem) elementsToRender.push(elem);
                }
                
                // Add answer option elements to rendering queue
                if (!isTextAnswer && problem.answer_options) {
                    Object.keys(problem.answer_options).forEach(key => {
                        const answerElement = document.getElementById(`answerOptionRendered_${key}`);
                        if (answerElement) {
                            elementsToRender.push(answerElement);
                        }
                    });
                }
                
                // Add subproblem elements to rendering queue
                if (problem.subproblems) {
                    Object.keys(problem.subproblems).forEach(key => {
                        const subproblem = problem.subproblems[key];
                        
                        // Subproblem text
                        const subproblemElement = document.getElementById(`subproblemRendered_${key}`);
                        if (subproblemElement) elementsToRender.push(subproblemElement);
                        
                        // Subproblem answer
                        const subproblemAnswerElement = document.getElementById(`subproblemAnswerRendered_${key}`);
                        if (subproblemAnswerElement) elementsToRender.push(subproblemAnswerElement);
                        
                        // Subproblem hint (single)
                        if (subproblem && subproblem.hint) {
                            const elem = document.getElementById(`subHintRendered_${key}_single`);
                            if (elem) elementsToRender.push(elem);
                        }
                        
                        // Subproblem solution (single)
                        if (subproblem && subproblem.solution && subproblem.solution.text) {
                            const elem = document.getElementById(`subSolutionRendered_${key}_single`);
                            if (elem) elementsToRender.push(elem);
                        }
                        
                        // Subproblem comment
                        const subCommentElement = document.getElementById(`subproblemCommentRendered_${key}`);
                        if (subCommentElement) elementsToRender.push(subCommentElement);
                    });
                }
                
                // Add comment element
                const commentElement = document.getElementById('commentRendered');
                if (commentElement) elementsToRender.push(commentElement);
                
                // Auto-resize all textareas after rendering
                setTimeout(() => {
                    document.querySelectorAll('textarea').forEach(textarea => {
                        autoResizeTextarea(textarea);
                    });
                }, 100);
                
                // Render all LaTeX elements
                if (elementsToRender.length > 0) {
                    MathJax.typesetPromise(elementsToRender).catch(err => {
                        console.error('MathJax rendering error:', err);
                    });
                }
            }
        }

        function toggleProblemTextEdit() {
            const display = document.getElementById('problemTextDisplay');
            const rendered = document.getElementById('problemTextRendered');
            const edit = document.getElementById('problemTextEdit');
            
            if (display.style.display === 'none') {
                // Save and switch to display mode
                const textarea = document.getElementById('problemTextTextarea');
                const newText = textarea.value;
                
                // Clear any existing MathJax processing first
                if (window.MathJax) {
                    MathJax.typesetClear([rendered]);
                }
                
                // Process the text to convert image placeholders to actual images
                let processedHtml = processImagePlaceholders(newText);
                // Also preprocess LaTeX lists
                processedHtml = preprocessLatexLists(processedHtml);
                
                // Set the new content
                rendered.innerHTML = processedHtml;
                display.style.display = 'block';
                edit.style.display = 'none';
                updateProblem('problem_text', newText);
                
                // Re-render LaTeX with proper promise chaining
                if (window.MathJax) {
                    MathJax.typesetPromise([rendered]).catch((err) => {
                        console.log('MathJax typeset error:', err);
                        // Fallback: just show the processed text if MathJax fails
                        rendered.innerHTML = processedHtml;
                    });
                }
            } else {
                // Switch to edit mode
                display.style.display = 'none';
                edit.style.display = 'flex';
                const textarea = document.getElementById('problemTextTextarea');
                
                // Ensure textarea has the current data value, not potentially modified DOM content
                if (currentProblemIndex >= 0) {
                    textarea.value = problemsData.problems[currentProblemIndex].problem_text || '';
                }
                
                textarea.focus();
                autoResizeTextarea(textarea);
            }
        }

        function saveProblemText() {
            toggleProblemTextEdit();
        }

        function toggleTextAnswerEdit() {
            const display = document.getElementById('textAnswerDisplay');
            const rendered = document.getElementById('textAnswerRendered');
            const edit = document.getElementById('textAnswerEdit');
            
            if (display.style.display === 'none') {
                // Save and switch to display mode
                const newText = edit.querySelector('textarea').value;
                
                // Clear any existing MathJax processing first
                if (window.MathJax) {
                    MathJax.typesetClear([rendered]);
                }
                
                // Set the new text content with preprocessing
                rendered.innerHTML = preprocessLatexLists(newText);
                display.style.display = 'block';
                edit.style.display = 'none';
                updateProblem('correct_answer', newText);
                
                // Re-render LaTeX with proper promise chaining
                if (window.MathJax) {
                    MathJax.typesetPromise([rendered]).catch((err) => {
                        console.log('MathJax typeset error:', err);
                        // Fallback: just show the raw text if MathJax fails
                        rendered.innerHTML = newText;
                    });
                }
            } else {
                // Switch to edit mode
                display.style.display = 'none';
                edit.style.display = 'flex';
                const textarea = edit.querySelector('textarea');
                
                // Ensure textarea has the current data value
                if (currentProblemIndex >= 0) {
                    textarea.value = problemsData.problems[currentProblemIndex].correct_answer || '';
                }
                
                textarea.focus();
                autoResizeTextarea(textarea);
            }
        }

        function saveTextAnswer() {
            toggleTextAnswerEdit();
        }

        function toggleCommentEdit() {
            const display = document.getElementById('commentDisplay');
            const rendered = document.getElementById('commentRendered');
            const edit = document.getElementById('commentEdit');
            
            if (display.style.display === 'none') {
                // Save and switch to display mode
                const newText = document.getElementById('commentTextarea').value;
                
                // Clear any existing MathJax processing first
                if (window.MathJax) {
                    MathJax.typesetClear([rendered]);
                }
                
                // Set the new text content with preprocessing
                rendered.innerHTML = preprocessLatexLists(newText);
                display.style.display = 'block';
                edit.style.display = 'none';
                updateProblem('comment', newText);
                
                // Re-render LaTeX with proper promise chaining
                if (window.MathJax) {
                    MathJax.typesetPromise([rendered]).catch((err) => {
                        console.log('MathJax typeset error:', err);
                        // Fallback: just show the raw text if MathJax fails
                        rendered.innerHTML = newText;
                    });
                }
            } else {
                // Switch to edit mode
                display.style.display = 'none';
                edit.style.display = 'flex';
                const textarea = document.getElementById('commentTextarea');
                
                // Ensure textarea has the current data value
                if (currentProblemIndex >= 0) {
                    textarea.value = problemsData.problems[currentProblemIndex].comment || '';
                }
                
                textarea.focus();
                autoResizeTextarea(textarea);
            }
        }

        function saveComment() {
            toggleCommentEdit();
        }

        // Legacy functions kept for backward compatibility
        function saveSolution() {
            // No longer needed with new individual solution boxes
        }

        function generateProblemImage(images) {
            return generateImageSection(images);
        }

        // Helper function to generate Supabase storage URLs for images
        function getSupabaseImageUrl(documentId, imageName) {
            return `${SUPABASE_URL}/storage/v1/object/public/${STORAGE_BUCKET}/${documentId}/images/${imageName}`;
        }

        function generateImageSection(images, context = 'problem') {
            const hasImages = images && images.length > 0;
            
            if (!hasImages) {
                return '';
            }
            
            const imageCount = images.length;
            // Use document ID if available, fallback to currentFileName
            const documentId = problemsData?.document?.id || problemsData?.doc?.id || currentFileName;
            
            const imageContent = images.map((image, index) => {
                // Use Supabase storage URL
                const imagePath = getSupabaseImageUrl(documentId, image);
                return `
                    <div class="image-item" style="margin-bottom: 15px; position: relative; display: inline-block;">
                        <button class="image-remove-btn" onclick="removeImageFromContext('${context}', ${index})" title="Remove image">×</button>
                        <img src="${imagePath}" alt="Problem image" style="max-width: 100%; max-height: 200px; border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.1);" onerror="this.style.display='none'; this.nextElementSibling.style.display='block';">
                        <div class="no-image" style="display: none; color: #6c757d; font-style: italic; padding: 20px; background: #f8f9fa; border-radius: 8px; border: 2px dashed #dee2e6;">Image not found: ${image}</div>
                        <div style="text-align: center; margin-top: 8px; font-size: 12px; color: #6c757d;">${image}</div>
                    </div>
                `;
            }).join('');
            
            return `
                <div class="images-header" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; padding: 10px; background: #e9ecef; border-radius: 6px;">
                    <span style="font-weight: 600; color: #495057;">Images (${imageCount})</span>
                </div>
                <div class="images-content">
                    ${imageContent}
                </div>
            `;
        }

        function generateSubproblemImageSection(images, subproblemKey) {
            const hasImages = images && images.length > 0;
            
            if (!hasImages) {
                return '';
            }
            
            // Use document ID if available, fallback to currentFileName
            const documentId = problemsData?.document?.id || problemsData?.doc?.id || currentFileName;
            
            return images.map((image, index) => {
                // Use Supabase storage URL
                const imagePath = getSupabaseImageUrl(documentId, image);
                return `
                    <div class="image-item" style="margin-bottom: 15px; position: relative; display: inline-block;">
                        <button class="image-remove-btn" onclick="removeImageFromSubproblem('${subproblemKey}', ${index})" title="Remove image">×</button>
                        <img src="${imagePath}" alt="Subproblem image" style="max-width: 100%; max-height: 200px; border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.1);" onerror="this.style.display='none'; this.nextElementSibling.style.display='block';">
                        <div class="no-image" style="display: none; color: #6c757d; font-style: italic; padding: 20px; background: #f8f9fa; border-radius: 8px; border: 2px dashed #dee2e6;">Image not found: ${image}</div>
                        <div style="text-align: center; margin-top: 8px; font-size: 12px; color: #6c757d;">${image}</div>
                    </div>
                `;
            }).join('');
        }

        function generateAnswerOptions(answerOptions) {
            if (!answerOptions) {
                return '<p style="color: #6c757d; font-style: italic;">No answer options available</p>';
            }

            return Object.entries(answerOptions).map(([key, value]) => `
                <div class="answer-option-display" onclick="toggleAnswerOptionEdit('${key}')" id="answerOptionDisplay_${key}">
                    <div class="answer-option-label">${key}:</div>
                    <div id="answerOptionRendered_${key}">${preprocessLatexLists(value)}</div>
                </div>
                <div class="answer-option" id="answerOptionEdit_${key}" style="display: none;">
                    <div class="answer-option-label">${key}:</div>
                    <textarea onchange="updateAnswerOption('${key}', this.value)" onblur="saveAnswerOption('${key}')" onkeydown="handleMultilineEdit(event)" placeholder="Enter answer option...">${value}</textarea>
                </div>
            `).join('');
        }

        function toggleAnswerOptionEdit(key) {
            const display = document.getElementById(`answerOptionDisplay_${key}`);
            const edit = document.getElementById(`answerOptionEdit_${key}`);
            
            if (display.style.display === 'none') {
                // Save and switch to display mode
                const newValue = edit.querySelector('textarea').value;
                const rendered = document.getElementById(`answerOptionRendered_${key}`);
                
                // Clear any existing MathJax processing first
                if (window.MathJax) {
                    MathJax.typesetClear([rendered]);
                }
                
                // Set the new text content with preprocessing
                rendered.innerHTML = preprocessLatexLists(newValue);
                display.style.display = 'block';
                edit.style.display = 'none';
                updateAnswerOption(key, newValue);
                
                // Re-render LaTeX with proper promise chaining
                if (window.MathJax) {
                    MathJax.typesetPromise([rendered]).catch((err) => {
                        console.log('MathJax typeset error:', err);
                        // Fallback: just show the raw text if MathJax fails
                        rendered.innerHTML = newValue;
                    });
                }
            } else {
                // Switch to edit mode
                display.classList.add('editing');
                display.style.display = 'none';
                edit.style.display = 'flex';
                const textarea = edit.querySelector('textarea');
                textarea.focus();
                autoResizeTextarea(textarea);
            }
        }

        function saveAnswerOption(key) {
            toggleAnswerOptionEdit(key);
        }

        function generateCorrectAnswerOptions(answerOptions) {
            if (!answerOptions) return '';
            
            return Object.keys(answerOptions).map(key => 
                `<option value="${key}">${key}</option>`
            ).join('');
        }

        function generateTopicsList(topicIds) {
            if (!topicIds || topicIds.length === 0) {
                return '<p style="color: #6c757d; font-style: italic;">No topics added</p>';
            }

            return topicIds.map(topicId => {
                const topic = availableTopics.find(t => t.id === topicId);
                const displayName = topic ? topic.name : `Topic ${topicId}`;
                return `
                    <div class="topic-tag" onclick="removeTopic(${topicId})">
                        ${displayName}
                        <span class="remove">×</span>
                    </div>
                `;
            }).join('');
        }

        function generateSubproblemsSection(subproblems) {
            const hasSubproblems = subproblems && Object.keys(subproblems).length > 0;
            
            const subproblemItems = hasSubproblems ? Object.entries(subproblems).sort().map(([key, subproblemData]) => {
                // Handle both old format (string) and new format (object)
                const problemText = typeof subproblemData === 'string' ? subproblemData : (subproblemData.problem_text || '');
                const correctAnswer = typeof subproblemData === 'object' ? (subproblemData.correct_answer || '') : '';
                // Handle solution object format
                let solution = '';
                if (typeof subproblemData === 'object') {
                    if (subproblemData.solution) {
                        if (typeof subproblemData.solution === 'string') {
                            solution = subproblemData.solution;
                        } else if (subproblemData.solution.text) {
                            solution = subproblemData.solution.text;
                        }
                    }
                }
                const images = typeof subproblemData === 'object' ? (subproblemData.images || []) : [];
                
                return `
                <div class="subproblem-item" id="subproblemItem_${key}">
                    <div class="subproblem-label">${key}:
                        <button class="subproblem-remove" onclick="removeSubproblem('${key}')">Remove</button>
                    </div>
                    <div class="problem-text-display" onclick="toggleSubproblemEdit('${key}')" id="subproblemDisplay_${key}">
                        <div id="subproblemRendered_${key}">${preprocessLatexLists(problemText)}</div>
                    </div>
                    <div class="answer-option" id="subproblemEdit_${key}" style="display: none;">
                        <textarea onchange="updateSubproblemText('${key}', this.value)" onblur="saveSubproblem('${key}')" onkeydown="handleMultilineEdit(event)" placeholder="Enter subproblem text...">${problemText}</textarea>
                    </div>
                    ${images.length > 0 ? `
                    <div class="form-group" style="margin-top: 10px;">
                        <label class="form-label" style="font-size: 12px;">Images (${key})</label>
                        <div class="problem-image">
                            ${generateSubproblemImageSection(images, key)}
                        </div>
                    </div>
                    ` : ''}
                    <div class="form-group" style="margin-top: 10px;">
                        <label class="form-label" style="font-size: 12px;">Hint (${key})</label>
                        <div id="subproblemHintsContainer_${key}">
                            ${generateSubproblemHintSection(typeof subproblemData === 'object' ? (subproblemData.hint || null) : null, key)}
                        </div>
                    </div>
                    <div class="form-group" style="margin-top: 10px;">
                        <label class="form-label" style="font-size: 12px;">Solution (${key})</label>
                        <div id="subproblemSolutionsContainer_${key}">
                            ${generateSubproblemSolutionSection(typeof subproblemData === 'object' && subproblemData.solution ? subproblemData.solution : solution, key)}
                        </div>
                    </div>
                    <div class="form-group" style="margin-top: 10px;">
                        <label class="form-label" style="font-size: 12px;">Correct Answer (${key})</label>
                        <div class="problem-text-display" onclick="toggleSubproblemAnswerEdit('${key}')" id="subproblemAnswerDisplay_${key}">
                            <div id="subproblemAnswerRendered_${key}">${preprocessLatexLists(correctAnswer)}</div>
                        </div>
                        <div class="answer-option" id="subproblemAnswerEdit_${key}" style="display: none;">
                            <textarea onchange="updateSubproblemAnswer('${key}', this.value)" onblur="saveSubproblemAnswer('${key}')" onkeydown="handleMultilineEdit(event)" placeholder="Enter correct answer...">${correctAnswer}</textarea>
                        </div>
                    </div>
                    <div class="form-group" style="margin-top: 10px;">
                        <button class="btn btn-primary" onclick="toggleSubproblemComment('${key}')" type="button" style="font-size: 12px; padding: 4px 8px;">Add Comment</button>
                        <div id="subproblemCommentContainer_${key}" style="display: none; margin-top: 10px;">
                            <label class="form-label" style="font-size: 12px;">Comment (${key})</label>
                            <div class="problem-text-display" onclick="toggleSubproblemCommentEdit('${key}')" id="subproblemCommentDisplay_${key}">
                                <div id="subproblemCommentRendered_${key}">${preprocessLatexLists(typeof subproblemData === 'object' ? (subproblemData.comment || '') : '')}</div>
                            </div>
                            <div class="answer-option" id="subproblemCommentEdit_${key}" style="display: none;">
                                <textarea onchange="updateSubproblemComment('${key}', this.value)" onblur="saveSubproblemComment('${key}')" onkeydown="handleMultilineEdit(event)" placeholder="Enter comment...">${typeof subproblemData === 'object' ? (subproblemData.comment || '') : ''}</textarea>
                            </div>
                        </div>
                    </div>
                </div>
                `;
            }).join('') : '';

            const expandedClass = hasSubproblems ? 'expanded' : '';
            const toggleSymbol = hasSubproblems ? '▼' : '▶';
            const count = hasSubproblems ? Object.keys(subproblems).length : 0;

            return `
                <div class="subproblems-container">
                    <div class="subproblems-header" onclick="toggleSubproblems()">
                        <span>Sub-Problems (${count})</span>
                        <span class="subproblems-toggle ${expandedClass}" id="subproblemsToggle">${toggleSymbol}</span>
                    </div>
                    <div class="subproblems-content ${expandedClass}" id="subproblemsContent">
                        ${subproblemItems}
                        <div class="subproblem-controls">
                            <input type="text" class="subproblem-add-input" id="newSubproblemKey" placeholder="a" maxlength="1">
                            <button class="btn btn-primary" onclick="addSubproblem()">Add Subproblem</button>
                        </div>
                    </div>
                </div>
            `;
        }


        function generateApproachButtons(approach) {
            const availableApproaches = ['Algebraic', 'Geometric', 'Combinatorial', 'Approximation', 'Intuitive', 'Algorithmic', 'Logical', 'Symmetric', 'Statistical', 'Nontraditional'];
            
            return availableApproaches.map(availableApproach => `
                <button class="approach-btn ${approach && approach.toLowerCase() === availableApproach.toLowerCase() ? 'selected' : ''}" onclick="toggleApproach('${availableApproach}')">
                    ${availableApproach}
                </button>
            `).join('');
        }

        function generateReasoningButtons(reasoning) {
            const availableReasonings = ['Proof-based', 'Example Construction', 'Counterexample Construction', 'Computational', 'Conceptual', 'Application-based'];
            
            return availableReasonings.map(availableReasoning => `
                <button class="reasoning-btn ${reasoning && reasoning.toLowerCase() === availableReasoning.toLowerCase() ? 'selected' : ''}" onclick="toggleReasoning('${availableReasoning}')">
                    ${availableReasoning}
                </button>
            `).join('');
        }

        function updateProblem(field, value) {
            if (currentProblemIndex >= 0) {
                problemsData.problems[currentProblemIndex][field] = value;
                // Don't auto-update completion status here
            }
        }

        function updateSolution(value) {
            if (currentProblemIndex >= 0) {
                // Handle both old format (string) and new format (object)
                if (!problemsData.problems[currentProblemIndex].solution) {
                    problemsData.problems[currentProblemIndex].solution = {
                        text: value,
                        images: []
                    };
                } else if (typeof problemsData.problems[currentProblemIndex].solution === 'string') {
                    // Convert old format to new format
                    problemsData.problems[currentProblemIndex].solution = {
                        text: value,
                        images: []
                    };
                } else {
                    // Update existing object format
                    problemsData.problems[currentProblemIndex].solution.text = value;
                }
            }
        }

        function updateSolutionFromTextarea() {
            const textarea = document.getElementById('solutionTextarea');
            if (textarea) {
                updateSolution(textarea.value);
            }
        }

        function updateAnswerOption(key, value) {
            if (currentProblemIndex >= 0) {
                if (!problemsData.problems[currentProblemIndex].answer_options) {
                    problemsData.problems[currentProblemIndex].answer_options = {};
                }
                problemsData.problems[currentProblemIndex].answer_options[key] = value;
                // Don't auto-update completion status here
            }
        }

        function setDifficulty(difficulty) {
            if (currentProblemIndex >= 0) {
                problemsData.problems[currentProblemIndex].difficulty = difficulty;
            }
            
            // Update UI
            document.querySelectorAll('.difficulty-btn').forEach(btn => {
                btn.classList.remove('selected');
            });
            event.target.classList.add('selected');
        }

        function filterTopics() {
            console.log('filterTopics called');
            const searchInput = document.getElementById('topicSearchInput');
            const dropdown = document.getElementById('topicsDropdown');
            
            if (!searchInput) {
                console.log('searchInput not found');
                return;
            }
            
            if (!dropdown) {
                console.log('dropdown not found');
                return;
            }
            
            const searchTerm = searchInput.value.toLowerCase();
            console.log('Search term:', searchTerm);
            console.log('Available topics:', availableTopics.length);
            
            // Get current topic IDs, default to empty array if no problem selected
            const currentTopicIds = (currentProblemIndex >= 0 && problemsData && problemsData.problems) 
                ? (problemsData.problems[currentProblemIndex].topics || [])
                : [];
            
            console.log('Current topic IDs:', currentTopicIds);
            
            let filteredTopics;
            if (!searchTerm) {
                // Show all topics if no search term
                filteredTopics = availableTopics.filter(topic => !currentTopicIds.includes(topic.id));
            } else {
                // Filter by search term
                filteredTopics = availableTopics.filter(topic => 
                    topic.name.toLowerCase().includes(searchTerm) && 
                    !currentTopicIds.includes(topic.id)
                );
            }
            
            console.log('Filtered topics:', filteredTopics.length);
            
            dropdown.innerHTML = filteredTopics.map(topic => `
                <div class="topics-dropdown-item" onmousedown="addTopicById(${topic.id})">
                    ${topic.name}
                </div>
            `).join('');
            
            if (filteredTopics.length === 0 && searchTerm) {
                dropdown.innerHTML = '<div class="topics-dropdown-item" style="color: #6c757d; font-style: italic;">No topics found</div>';
            }
        }

        function showTopicsDropdown() {
            console.log('showTopicsDropdown called');
            const dropdown = document.getElementById('topicsDropdown');
            if (!dropdown) {
                console.log('dropdown element not found');
                return;
            }
            dropdown.style.display = 'block';
            console.log('dropdown display set to block');
            filterTopics(); // Show filtered results
        }

        function handleTopicInput() {
            console.log('handleTopicInput called');
            showTopicsDropdown();
            filterTopics();
        }

        function testTopicsDropdown() {
            console.log('Test button clicked');
            console.log('Available topics:', availableTopics.length);
            const dropdown = document.getElementById('topicsDropdown');
            if (dropdown) {
                dropdown.style.display = dropdown.style.display === 'none' ? 'block' : 'none';
                if (dropdown.style.display === 'block') {
                    filterTopics();
                }
            }
        }

        function hideTopicsDropdown() {
            setTimeout(() => {
                const dropdown = document.getElementById('topicsDropdown');
                if (dropdown) {
                    dropdown.style.display = 'none';
                }
                const searchInput = document.getElementById('topicSearchInput');
                if (searchInput) {
                    searchInput.value = '';
                }
            }, 300); // Longer delay to allow click events to fire
        }

        function addTopicById(topicId) {
            console.log('addTopicById called with ID:', topicId);
            
            if (currentProblemIndex >= 0 && problemsData && problemsData.problems) {
                // Set only one topic (replace existing)
                problemsData.problems[currentProblemIndex].topics = [topicId];
                console.log('Topic set:', topicId);
                updateTopicsList();
                
                // Clear search and hide dropdown
                const searchInput = document.getElementById('topicSearchInput');
                const dropdown = document.getElementById('topicsDropdown');
                if (searchInput) searchInput.value = '';
                if (dropdown) dropdown.style.display = 'none';
            } else {
                console.log('No problem selected or problemsData not available');
                alert('Please load a JSON file and select a problem first');
            }
        }

        function removeTopic(topicId) {
            if (currentProblemIndex >= 0) {
                const topics = problemsData.problems[currentProblemIndex].topics;
                const index = topics.indexOf(topicId);
                if (index > -1) {
                    topics.splice(index, 1);
                    updateTopicsList();
                }
            }
        }

        function updateTopicsList() {
            const topicsList = document.getElementById('topicsList');
            const topics = problemsData.problems[currentProblemIndex].topics || [];
            topicsList.innerHTML = generateTopicsList(topics);
        }

        function toggleSubproblems() {
            const content = document.getElementById('subproblemsContent');
            const toggle = document.getElementById('subproblemsToggle');
            
            if (content.classList.contains('expanded')) {
                content.classList.remove('expanded');
                toggle.classList.remove('expanded');
                toggle.textContent = '▶';
            } else {
                content.classList.add('expanded');
                toggle.classList.add('expanded');
                toggle.textContent = '▼';
            }
        }

        function toggleSubproblemEdit(key) {
            const display = document.getElementById(`subproblemDisplay_${key}`);
            const rendered = document.getElementById(`subproblemRendered_${key}`);
            const edit = document.getElementById(`subproblemEdit_${key}`);
            
            if (display.style.display === 'none') {
                // Save and switch to display mode
                const newText = edit.querySelector('textarea').value;
                
                // Clear any existing MathJax processing first
                if (window.MathJax) {
                    MathJax.typesetClear([rendered]);
                }
                
                // Set the new text content with preprocessing
                rendered.innerHTML = preprocessLatexLists(newText);
                display.style.display = 'block';
                edit.style.display = 'none';
                updateSubproblemText(key, newText);
                
                // Re-render LaTeX with proper promise chaining
                if (window.MathJax) {
                    MathJax.typesetPromise([rendered]).catch((err) => {
                        console.log('MathJax typeset error:', err);
                        // Fallback: just show the raw text if MathJax fails
                        rendered.innerHTML = newText;
                    });
                }
            } else {
                // Switch to edit mode
                display.style.display = 'none';
                edit.style.display = 'flex';
                const textarea = edit.querySelector('textarea');
                textarea.focus();
                autoResizeTextarea(textarea);
            }
        }

        function saveSubproblem(key) {
            toggleSubproblemEdit(key);
        }

        function toggleSubproblemAnswerEdit(key) {
            const display = document.getElementById(`subproblemAnswerDisplay_${key}`);
            const rendered = document.getElementById(`subproblemAnswerRendered_${key}`);
            const edit = document.getElementById(`subproblemAnswerEdit_${key}`);
            
            if (display.style.display === 'none') {
                // Save and switch to display mode
                const newText = edit.querySelector('textarea').value;
                
                // Clear any existing MathJax processing first
                if (window.MathJax) {
                    MathJax.typesetClear([rendered]);
                }
                
                // Set the new text content with preprocessing
                rendered.innerHTML = preprocessLatexLists(newText);
                display.style.display = 'block';
                edit.style.display = 'none';
                updateSubproblemAnswer(key, newText);
                
                // Re-render LaTeX with proper promise chaining
                if (window.MathJax) {
                    MathJax.typesetPromise([rendered]).catch((err) => {
                        console.log('MathJax typeset error:', err);
                        // Fallback: just show the raw text if MathJax fails
                        rendered.innerHTML = newText;
                    });
                }
            } else {
                // Switch to edit mode
                display.style.display = 'none';
                edit.style.display = 'flex';
                const textarea = edit.querySelector('textarea');
                textarea.focus();
                autoResizeTextarea(textarea);
            }
        }

        function saveSubproblemAnswer(key) {
            toggleSubproblemAnswerEdit(key);
        }

        // Legacy functions kept for backward compatibility
        function saveSubproblemSolution(key) {
            // No longer needed with new individual solution boxes
        }

        function updateSubproblemText(key, value) {
            if (currentProblemIndex >= 0) {
                if (!problemsData.problems[currentProblemIndex].subproblems) {
                    problemsData.problems[currentProblemIndex].subproblems = {};
                }
                if (!problemsData.problems[currentProblemIndex].subproblems[key]) {
                    problemsData.problems[currentProblemIndex].subproblems[key] = {
                        problem_text: null,
                        correct_answer: null,
                        hint: null,
                        solution: { text: null, images: [] },
                        images: [],
                        comment: null
                    };
                }
                problemsData.problems[currentProblemIndex].subproblems[key].problem_text = value;
            }
        }

        function updateSubproblemAnswer(key, value) {
            if (currentProblemIndex >= 0) {
                if (!problemsData.problems[currentProblemIndex].subproblems) {
                    problemsData.problems[currentProblemIndex].subproblems = {};
                }
                if (!problemsData.problems[currentProblemIndex].subproblems[key]) {
                    problemsData.problems[currentProblemIndex].subproblems[key] = {
                        problem_text: null,
                        correct_answer: null,
                        hint: null,
                        solution: { text: null, images: [] },
                        images: [],
                        comment: null
                    };
                }
                problemsData.problems[currentProblemIndex].subproblems[key].correct_answer = value;
            }
        }

        function toggleSubproblemComment(key) {
            const container = document.getElementById(`subproblemCommentContainer_${key}`);
            if (container) {
                if (container.style.display === 'none') {
                    container.style.display = 'block';
                } else {
                    container.style.display = 'none';
                }
            }
        }

        function toggleSubproblemCommentEdit(key) {
            const display = document.getElementById(`subproblemCommentDisplay_${key}`);
            const rendered = document.getElementById(`subproblemCommentRendered_${key}`);
            const edit = document.getElementById(`subproblemCommentEdit_${key}`);
            
            if (display.style.display === 'none') {
                // Save and switch to display mode
                const newText = edit.querySelector('textarea').value;
                
                // Clear any existing MathJax processing first
                if (window.MathJax) {
                    MathJax.typesetClear([rendered]);
                }
                
                // Set the new text content with preprocessing
                rendered.innerHTML = preprocessLatexLists(newText);
                display.style.display = 'block';
                edit.style.display = 'none';
                updateSubproblemComment(key, newText);
                
                // Re-render LaTeX with proper promise chaining
                if (window.MathJax) {
                    MathJax.typesetPromise([rendered]).catch((err) => {
                        console.log('MathJax typeset error:', err);
                        // Fallback: just show the raw text if MathJax fails
                        rendered.innerHTML = newText;
                    });
                }
            } else {
                // Switch to edit mode
                display.style.display = 'none';
                edit.style.display = 'flex';
                const textarea = edit.querySelector('textarea');
                
                // Ensure textarea has the current data value
                if (currentProblemIndex >= 0 && problemsData.problems[currentProblemIndex].subproblems && 
                    problemsData.problems[currentProblemIndex].subproblems[key]) {
                    textarea.value = problemsData.problems[currentProblemIndex].subproblems[key].comment || '';
                }
                
                textarea.focus();
                autoResizeTextarea(textarea);
            }
        }

        function saveSubproblemComment(key) {
            toggleSubproblemCommentEdit(key);
        }

        function updateSubproblemComment(key, value) {
            if (currentProblemIndex >= 0) {
                if (!problemsData.problems[currentProblemIndex].subproblems) {
                    problemsData.problems[currentProblemIndex].subproblems = {};
                }
                if (!problemsData.problems[currentProblemIndex].subproblems[key]) {
                    problemsData.problems[currentProblemIndex].subproblems[key] = {
                        problem_text: null,
                        correct_answer: null,
                        hint: null,
                        solution: { text: null, images: [] },
                        images: [],
                        comment: null
                    };
                }
                problemsData.problems[currentProblemIndex].subproblems[key].comment = value;
            }
        }

        // Legacy function kept for backward compatibility
        function updateSubproblemSolution(key, value) {
            // This function is now handled by updateSubproblemSolutionAtIndex
        }


        function toggleApproach(approach) {
            if (currentProblemIndex >= 0) {
                const currentApproach = problemsData.problems[currentProblemIndex].math_approach;
                const approachLower = approach.toLowerCase();
                
                if (currentApproach && currentApproach.toLowerCase() === approachLower) {
                    // Remove approach (deselect)
                    problemsData.problems[currentProblemIndex].math_approach = null;
                } else {
                    // Set new approach
                    problemsData.problems[currentProblemIndex].math_approach = approachLower;
                }
                
                updateApproachButtons();
            }
        }

        function updateApproachButtons() {
            const approachButtons = document.getElementById('approachButtons');
            const approach = problemsData.problems[currentProblemIndex].math_approach || null;
            approachButtons.innerHTML = generateApproachButtons(approach);
        }

        function toggleReasoning(reasoning) {
            if (currentProblemIndex >= 0) {
                const currentReasoning = problemsData.problems[currentProblemIndex].reasoning_type;
                const reasoningLower = reasoning.toLowerCase();
                
                if (currentReasoning && currentReasoning.toLowerCase() === reasoningLower) {
                    // Remove reasoning (deselect)
                    problemsData.problems[currentProblemIndex].reasoning_type = null;
                } else {
                    // Set new reasoning
                    problemsData.problems[currentProblemIndex].reasoning_type = reasoningLower;
                }
                
                updateReasoningButtons();
            }
        }

        function updateReasoningButtons() {
            const reasoningButtons = document.querySelector('.reasoning-buttons');
            const reasoning = problemsData.problems[currentProblemIndex].reasoning_type || null;
            reasoningButtons.innerHTML = generateReasoningButtons(reasoning);
        }


        function removeProblem() {
            if (currentProblemIndex >= 0 && confirm('Are you sure you want to remove this entire problem? This action cannot be undone.')) {
                // Remove the problem from the array
                problemsData.problems.splice(currentProblemIndex, 1);
                
                // Update localStorage
                localStorage.setItem('problemsData', JSON.stringify(problemsData));
                
                // Reload the problems list
                loadProblems();
                
                // Reset current index
                currentProblemIndex = -1;
                
                // Show no problem selected
                const editorPanel = document.querySelector('.editor-panel');
                editorPanel.innerHTML = `
                    <div id="noProblem" class="no-problem">
                        <h3>No Problem Selected</h3>
                        <p>Select a problem from the sidebar to start editing</p>
                    </div>
                `;
                
                showSuccess('Problem removed successfully!');
            }
        }

        function handleMultilineEdit(event) {
            if (event.key === 'Enter' && event.shiftKey) {
                // Allow line break with Shift+Enter
                return true;
            } else if (event.key === 'Enter' && !event.shiftKey) {
                // Prevent default Enter behavior and trigger blur to save
                event.preventDefault();
                event.target.blur();
            }
            
            // Auto-resize textarea
            autoResizeTextarea(event.target);
        }

        function htmlEscapeMathSymbols(text) {
            if (!text) return text;
            return text.replace(/</g, '&lt;').replace(/>/g, '&gt;');
        }

        function autoResizeTextarea(textarea) {
            textarea.style.height = 'auto';
            textarea.style.height = Math.max(60, textarea.scrollHeight) + 'px';
        }

        function addSubproblem() {
            const keyInput = document.getElementById('newSubproblemKey');
            const key = keyInput.value.trim().toLowerCase();
            
            if (!key || !/^[a-z]$/.test(key)) {
                alert('Please enter a single letter (a-z) for the subproblem key.');
                return;
            }
            
            if (currentProblemIndex >= 0) {
                if (!problemsData.problems[currentProblemIndex].subproblems) {
                    problemsData.problems[currentProblemIndex].subproblems = {};
                }
                
                if (problemsData.problems[currentProblemIndex].subproblems[key]) {
                    alert(`Subproblem ${key} already exists.`);
                    return;
                }
                
                // Add new subproblem with new structure
                problemsData.problems[currentProblemIndex].subproblems[key] = {
                    problem_text: '',
                    correct_answer: null,
                    solution: null
                };
                
                // Clear input
                keyInput.value = '';
                
                // Refresh the subproblems section
                refreshSubproblemsSection();
            }
        }

        function removeSubproblem(key) {
            if (currentProblemIndex >= 0) {
                delete problemsData.problems[currentProblemIndex].subproblems[key];
                
                // Keep subproblems as empty dict if no subproblems left
                if (Object.keys(problemsData.problems[currentProblemIndex].subproblems).length === 0) {
                    problemsData.problems[currentProblemIndex].subproblems = {};
                }
                
                // Refresh the subproblems section
                refreshSubproblemsSection();
            }
        }

        function refreshSubproblemsSection() {
            const problem = problemsData.problems[currentProblemIndex];
            const subproblemsContainer = document.querySelector('.subproblems-container');
            if (subproblemsContainer) {
                subproblemsContainer.outerHTML = generateSubproblemsSection(problem.subproblems);
                
                // Re-render LaTeX for new subproblems
                if (window.MathJax && problem.subproblems) {
                    const elementsToRender = [];
                    Object.keys(problem.subproblems).forEach(key => {
                        const subproblemElement = document.getElementById(`subproblemRendered_${key}`);
                        const subproblemAnswerElement = document.getElementById(`subproblemAnswerRendered_${key}`);
                        const subproblemHintElement = document.getElementById(`subproblemHintRendered_${key}`);
                        const subproblemSolutionElement = document.getElementById(`subproblemSolutionRendered_${key}`);
                        if (subproblemElement) {
                            elementsToRender.push(subproblemElement);
                        }
                        if (subproblemAnswerElement) {
                            elementsToRender.push(subproblemAnswerElement);
                        }
                        if (subproblemHintElement) {
                            elementsToRender.push(subproblemHintElement);
                        }
                        if (subproblemSolutionElement) {
                            elementsToRender.push(subproblemSolutionElement);
                        }
                    });
                    if (elementsToRender.length > 0) {
                        MathJax.typesetPromise(elementsToRender);
                    }
                }
            }
        }

        function refreshImageSection() {
            const problem = problemsData.problems[currentProblemIndex];
            const imageContainer = document.getElementById('problemImage');
            if (imageContainer) {
                imageContainer.innerHTML = generateImageSection(problem.images);
            }
        }


        function saveCurrentProblem() {
            if (currentProblemIndex >= 0) {
                // Save to localStorage as backup
                localStorage.setItem('problemsData', JSON.stringify(problemsData));
                if (originalFileName) {
                    localStorage.setItem('originalFileName', originalFileName);
                }
                
                // Update completion status
                
                // Update the problem status in the sidebar
                updateProblemStatus();
                
                showSuccess('Problem saved successfully!');
            }
        }

        function updateProblemStatus() {
            if (currentProblemIndex >= 0) {
                const problem = problemsData.problems[currentProblemIndex];
                const isComplete = isProblemComplete(problem);
                
                const problemItem = document.querySelectorAll('.problem-item')[currentProblemIndex];
                const statusElement = problemItem.querySelector('.problem-status');
                
                statusElement.className = `problem-status ${isComplete ? 'complete' : 'incomplete'}`;
                statusElement.textContent = ''; // No text, just icons
                
                updateStats();
            }
        }

        function updateAllProblemStatuses() {
            if (!problemsData || !problemsData.problems) {
                return;
            }

            const problemItems = document.querySelectorAll('.problem-item');
            problemsData.problems.forEach((problem, index) => {
                if (problemItems[index]) {
                    const isComplete = isProblemComplete(problem);
                    const statusElement = problemItems[index].querySelector('.problem-status');
                    
                    if (statusElement) {
                        statusElement.className = `problem-status ${isComplete ? 'complete' : 'incomplete'}`;
                        statusElement.textContent = ''; // No text, just icons
                    }
                }
            });
            
            updateStats();
        }

        function isProblemComplete(problem) {
            // Check if either problem_text exists OR at least one subproblem exists
            const hasContent = problem.problem_text || 
                              (problem.subproblems && Object.keys(problem.subproblems).length > 0 && 
                               Object.values(problem.subproblems).some(sp => sp && sp.problem_text && sp.problem_text.trim()));
            
            // Handle solution object format - check if solution has actual content
            let hasSolution = false;
            if (problem.solution) {
                if (typeof problem.solution === 'string' && problem.solution.trim()) {
                    hasSolution = true;
                } else if (problem.solution.text) {
                    if (Array.isArray(problem.solution.text)) {
                        hasSolution = problem.solution.text.some(text => text && text.trim());
                    } else if (typeof problem.solution.text === 'string') {
                        hasSolution = problem.solution.text.trim().length > 0;
                    }
                }
            }
            
            return hasContent &&
                   problem.correct_answer && 
                   hasSolution && 
                   problem.difficulty && 
                   problem.topics && Array.isArray(problem.topics) &&
                   problem.topics.length > 0 &&
                   true; // Domain removed
                   // Note: math_approach and reasoning_type are now optional
        }

        function updateStats() {
            if (!problemsData) return;

            const total = problemsData.problems.length;
            const completed = problemsData.problems.filter(p => isProblemComplete(p)).length;
            const incomplete = total - completed;

            document.getElementById('totalProblems').textContent = total;
            document.getElementById('completedProblems').textContent = completed;
            document.getElementById('incompleteProblems').textContent = incomplete;
            document.getElementById('stats').style.display = 'flex';
        }

        function exportData() {
            if (!problemsData) {
                showError('No data to export. Please load a JSON file first.');
                return;
            }

            // Create a copy for export
            const exportData = JSON.parse(JSON.stringify(problemsData));
            
            // Handle both old format (doc) and new format (document)
            const documentField = exportData.document || exportData.doc;
            if (exportData.doc && !exportData.document) {
                // Convert old format to new format
                exportData.document = exportData.doc;
                delete exportData.doc;
            }
            
            // Set updated_at timestamp in Eastern timezone with yyyy-mm-dd format
            const now = new Date();
            const easternTime = new Date(now.toLocaleString('en-US', { timeZone: 'America/New_York' }));
            const year = easternTime.getFullYear();
            const month = String(easternTime.getMonth() + 1).padStart(2, '0');
            const day = String(easternTime.getDate()).padStart(2, '0');
            const hours = String(easternTime.getHours()).padStart(2, '0');
            const minutes = String(easternTime.getMinutes()).padStart(2, '0');
            const seconds = String(easternTime.getSeconds()).padStart(2, '0');
            const timestampStr = `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
            
            // Update each problem's updated_at and version fields
            if (exportData.problems && Array.isArray(exportData.problems)) {
                exportData.problems.forEach(problem => {
                    // Set updated_at timestamp
                    problem.updated_at = timestampStr;
                    
                    // Increment version for each problem
                    if (problem.version === 'raw') {
                        problem.version = 'v1';
                    } else if (problem.version && problem.version.startsWith('v')) {
                        const currentVersion = parseInt(problem.version.substring(1));
                        if (!isNaN(currentVersion)) {
                            problem.version = `v${currentVersion + 1}`;
                        } else {
                            problem.version = 'v1';
                        }
                    } else {
                        problem.version = 'v1';
                    }
                });
            }

            const dataStr = JSON.stringify(exportData, null, 2);
            const dataBlob = new Blob([dataStr], {type: 'application/json'});
            const url = URL.createObjectURL(dataBlob);
            
            // Create filename with version suffix using the input file name and first problem's version
            const baseFileName = originalFileName ? originalFileName.replace('.json', '') : 'problems';
            const version = (exportData.problems && exportData.problems.length > 0) ? 
                          (exportData.problems[0].version || 'v1') : 'v1';
            const exportFileName = `${baseFileName}_${version}.json`;
            
            const link = document.createElement('a');
            link.href = url;
            link.download = exportFileName;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);

            showSuccess(`Data exported successfully as ${exportFileName}!`);
        }

        function showError(message) {
            const errorDiv = document.createElement('div');
            errorDiv.className = 'error';
            errorDiv.textContent = message;
            document.querySelector('.container').insertBefore(errorDiv, document.querySelector('.main-content'));
            
            setTimeout(() => {
                errorDiv.remove();
            }, 5000);
        }

        function showSuccess(message) {
            const successDiv = document.createElement('div');
            successDiv.className = 'success';
            successDiv.textContent = message;
            document.querySelector('.container').insertBefore(successDiv, document.querySelector('.main-content'));
            
            setTimeout(() => {
                successDiv.remove();
            }, 3000);
        }

        async function updateDatabase() {
            if (!problemsData) {
                showError('No data to update. Please load a JSON file first.');
                return;
            }

            try {
                // Show loading state
                const originalButton = event.target;
                const originalText = originalButton.innerHTML;
                originalButton.innerHTML = '⏳ Updating Database...';
                originalButton.disabled = true;

                console.log('Starting database update...');
                
                // Step 1: Insert or update document
                const documentData = problemsData.document;
                console.log('Inserting document:', documentData);
                
                const documentResponse = await insertDocument(documentData);
                const documentUuid = documentResponse.data[0].id;
                console.log('Document inserted with UUID:', documentUuid);

                // Step 2: Insert problems and related data
                let successfulInserts = 0;
                let totalProblems = problemsData.problems.length;

                for (const problem of problemsData.problems) {
                    try {
                        console.log(`Processing problem: ${problem.id}`);
                        
                        // Insert problem
                        const problemResponse = await insertProblem(problem, documentUuid);
                        const problemUuid = problemResponse.data[0].id;
                        console.log(`Problem inserted with UUID: ${problemUuid}`);

                        // Insert subproblems
                        if (problem.subproblems && Object.keys(problem.subproblems).length > 0) {
                            await insertSubproblems(problem.subproblems, problemUuid);
                        }

                        // Insert hints
                        if (problem.hint && problem.hint.length > 0) {
                            await insertHints(problem.hint, problemUuid, null);
                        }

                        // Insert solutions
                        if (problem.solution && problem.solution.text && problem.solution.text.length > 0) {
                            await insertSolutions(problem.solution.text, problemUuid, null);
                        }

                        // Insert images
                        if (problem.images && problem.images.length > 0) {
                            await insertImages(problem.images, problemUuid, null, null, 'problem');
                        }

                        // Insert topics
                        if (problem.topics && problem.topics.length > 0) {
                            await insertTopics(problem.topics, problemUuid);
                        }


                        // Insert approaches
                        if (problem.math_approach && problem.math_approach.length > 0) {
                            await insertApproaches(problem.math_approach, problemUuid);
                        }

                        // Insert reasoning types
                        if (problem.reasoning_type && problem.reasoning_type.length > 0) {
                            await insertReasoningTypes(problem.reasoning_type, problemUuid);
                        }

                        successfulInserts++;
                    } catch (problemError) {
                        console.error(`Error processing problem ${problem.id}:`, problemError);
                        showError(`Error processing problem ${problem.id}: ${problemError.message}`);
                    }
                }

                // Restore button state
                originalButton.innerHTML = originalText;
                originalButton.disabled = false;

                showSuccess(`Database updated successfully! Inserted ${successfulInserts}/${totalProblems} problems.`);
                console.log('Database update completed successfully');

            } catch (error) {
                console.error('Database update failed:', error);
                showError(`Database update failed: ${error.message}`);
                
                // Restore button state on error
                if (event && event.target) {
                    event.target.innerHTML = '🗃️ Update Database';
                    event.target.disabled = false;
                }
            }
        }

        // Helper functions for database operations
        async function insertDocument(documentData) {
            const payload = {
                document_id: documentData.id,
                school: documentData.school || null,
                course: documentData.course || null,
                problem_type: documentData.problem_type || null,
                term: documentData.term || null,
                year: documentData.year ? parseInt(documentData.year) : null,
                total_problems: documentData.total_problems || 0
            };

            const response = await fetch('/functions/v1/supabase-proxy', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    action: 'upsert',
                    table: 'documents',
                    data: payload,
                    onConflict: 'document_id'
                })
            });

            if (!response.ok) {
                throw new Error(`Document insert failed: ${response.statusText}`);
            }

            return await response.json();
        }

        async function insertProblem(problem, documentUuid) {
            const payload = {
                problem_id: problem.id,
                document_id: documentUuid,
                problem_text: problem.problem_text || null,
                correct_answer: problem.correct_answer || null,
                difficulty: problem.difficulty || null,
                importance: problem.importance || null,
                comment: problem.comment || null,
                version: problem.version || 'v1'
            };

            const response = await fetch('/functions/v1/supabase-proxy', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    action: 'upsert',
                    table: 'problems',
                    data: payload,
                    onConflict: 'problem_id'
                })
            });

            if (!response.ok) {
                throw new Error(`Problem insert failed: ${response.statusText}`);
            }

            return await response.json();
        }

        async function insertSubproblems(subproblems, problemUuid) {
            for (const [key, subproblem] of Object.entries(subproblems)) {
                const payload = {
                    problem_id: problemUuid,
                    key: key,
                    problem_text: subproblem.problem_text || null,
                    correct_answer: subproblem.correct_answer || null,
                    comment: subproblem.comment || null
                };

                const response = await fetch('/functions/v1/supabase-proxy', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        action: 'upsert',
                        table: 'subproblems',
                        data: payload,
                        onConflict: 'problem_id,key'
                    })
                });

                if (!response.ok) {
                    throw new Error(`Subproblem insert failed: ${response.statusText}`);
                }

                const subproblemResponse = await response.json();
                const subproblemUuid = subproblemResponse.data[0].id;

                // Insert subproblem hints
                if (subproblem.hint && subproblem.hint.length > 0) {
                    await insertHints(subproblem.hint, null, subproblemUuid);
                }

                // Insert subproblem solutions
                if (subproblem.solution && subproblem.solution.text && subproblem.solution.text.length > 0) {
                    await insertSolutions(subproblem.solution.text, null, subproblemUuid);
                }

                // Insert subproblem images
                if (subproblem.images && subproblem.images.length > 0) {
                    await insertImages(subproblem.images, null, subproblemUuid, null, 'subproblem');
                }
            }
        }

        async function insertHints(hints, problemUuid, subproblemUuid) {
            for (let i = 0; i < hints.length; i++) {
                const payload = {
                    problem_id: problemUuid,
                    subproblem_id: subproblemUuid,
                    hint_text: hints[i],
                    position: i
                };

                const response = await fetch('/functions/v1/supabase-proxy', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        action: 'insert',
                        table: 'problem_hints',
                        data: payload
                    })
                });

                if (!response.ok) {
                    throw new Error(`Hint insert failed: ${response.statusText}`);
                }
            }
        }

        async function insertSolutions(solutions, problemUuid, subproblemUuid) {
            for (let i = 0; i < solutions.length; i++) {
                const payload = {
                    problem_id: problemUuid,
                    subproblem_id: subproblemUuid,
                    solution_text: solutions[i],
                    position: i
                };

                const response = await fetch('/functions/v1/supabase-proxy', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        action: 'insert',
                        table: 'problem_solutions',
                        data: payload
                    })
                });

                if (!response.ok) {
                    throw new Error(`Solution insert failed: ${response.statusText}`);
                }
            }
        }

        async function insertImages(images, problemUuid, subproblemUuid, solutionUuid, context) {
            for (const image of images) {
                const payload = {
                    problem_id: problemUuid,
                    subproblem_id: subproblemUuid,
                    solution_id: solutionUuid,
                    image_path: image,
                    context: context
                };

                const response = await fetch('/functions/v1/supabase-proxy', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        action: 'insert',
                        table: 'problem_images',
                        data: payload
                    })
                });

                if (!response.ok) {
                    throw new Error(`Image insert failed: ${response.statusText}`);
                }
            }
        }

        async function insertTopics(topicIds, problemUuid) {
            for (const topicId of topicIds) {
                const payload = {
                    problem_id: problemUuid,
                    topic_id: topicId
                };

                const response = await fetch('/functions/v1/supabase-proxy', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        action: 'upsert',
                        table: 'problem_topics',
                        data: payload,
                        onConflict: 'problem_id,topic_id'
                    })
                });

                if (!response.ok) {
                    throw new Error(`Topic insert failed: ${response.statusText}`);
                }
            }
        }


        async function insertApproaches(approaches, problemUuid) {
            for (const approach of approaches) {
                const payload = {
                    problem_id: problemUuid,
                    approach: approach
                };

                const response = await fetch('/functions/v1/supabase-proxy', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        action: 'upsert',
                        table: 'approaches',
                        data: payload,
                        onConflict: 'problem_id,approach'
                    })
                });

                if (!response.ok) {
                    throw new Error(`Approach insert failed: ${response.statusText}`);
                }
            }
        }

        async function insertReasoningTypes(reasoningTypes, problemUuid) {
            for (const reasoningType of reasoningTypes) {
                const payload = {
                    problem_id: problemUuid,
                    reasoning_type: reasoningType
                };

                const response = await fetch('/functions/v1/supabase-proxy', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        action: 'upsert',
                        table: 'reasoning_types',
                        data: payload,
                        onConflict: 'problem_id,reasoning_type'
                    })
                });

                if (!response.ok) {
                    throw new Error(`Reasoning type insert failed: ${response.statusText}`);
                }
            }
        }

        // Don't auto-load previous session data on initial page load
        // Show clean boilerplate page instead
        window.addEventListener('load', function() {
            // Load topics data first
            loadTopics();
            // Clean start - no auto-loading of previous session
            console.log('Editor loaded - ready for new file upload');
        });

        // Auto-resize textareas on input
        document.addEventListener('input', function(event) {
            if (event.target.tagName === 'TEXTAREA') {
                autoResizeTextarea(event.target);
            }
        });

        // Image placeholder processing functions
        function processImagePlaceholders(text) {
            if (!text) return text;
            
            // Convert ![imagename.png] or ![imagename.png|size] to actual image tags using Supabase storage
            return text.replace(/!\[([^\|\]]+)(?:\|([^\]]+))?\]/g, function(match, imageName, size) {
                // Use document ID if available, fallback to currentFileName
                const documentId = problemsData?.document?.id || problemsData?.doc?.id || currentFileName;
                
                if (documentId && imageName) {
                    const imagePath = getSupabaseImageUrl(documentId, imageName);
                    
                    // Parse size parameter
                    let imageStyle = 'max-width: 100%; max-height: 300px;';
                    
                    if (size) {
                        if (size.includes('x')) {
                            // Format: widthxheight (e.g., "300x200")
                            const [width, height] = size.split('x');
                            imageStyle = `width: ${width}px; height: ${height}px;`;
                        } else if (size.includes('%')) {
                            // Percentage format (e.g., "50%")
                            imageStyle = `width: ${size}; height: auto;`;
                        } else {
                            // Single number = width in pixels (e.g., "300")
                            imageStyle = `width: ${size}px; height: auto;`;
                        }
                    }
                    
                    return `<div style="text-align: center; margin: 15px 0;">
                        <img src="${imagePath}" alt="${imageName}" style="${imageStyle} border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.1);" onerror="this.style.display='none'; this.nextElementSibling.style.display='block';">
                        <div style="display: none; color: #6c757d; font-style: italic; padding: 20px; background: #f8f9fa; border-radius: 8px; border: 2px dashed #dee2e6;">Image not found: ${imageName}</div>
                        <div style="font-size: 12px; color: #6c757d; margin-top: 8px;">${imageName}</div>
                    </div>`;
                } else {
                    return `<div style="color: #666; font-style: italic; padding: 10px; border: 1px dashed #ccc; border-radius: 4px; margin: 10px 0; background: #f8f9fa; text-align: center;">Image not found: ${imageName} (No document loaded)</div>`;
                }
            });
        }

        function insertImagePlaceholder(context, key = null) {
            let textarea;
            
            // Determine which textarea to target based on context
            switch (context) {
                case 'problem_solution':
                    textarea = document.getElementById('solutionTextarea');
                    break;
                case 'problemText':
                    textarea = document.getElementById('problemTextTextarea');
                    break;
                case 'subproblemSolution':
                    textarea = document.getElementById(`subproblemSolutionTextarea_${key}`);
                    break;
                default:
                    textarea = document.getElementById('solutionTextarea');
            }
            
            if (!textarea) return;
            
            // Get available images from the current problem
            let availableImages = [];
            if (currentProblemIndex >= 0) {
                const problem = problemsData.problems[currentProblemIndex];
                if (problem.images && problem.images.length > 0) {
                    availableImages = [...problem.images];
                }
                if (problem.solution && problem.solution.images && problem.solution.images.length > 0) {
                    availableImages = [...availableImages, ...problem.solution.images];
                }
            }
            
            if (availableImages.length === 0) {
                alert('No images available for this problem. Upload images first or add them to the problem/solution images array.');
                return;
            }
            
            // Show a simple selection of available images
            let imageSelection = 'Available images:\\n';
            availableImages.forEach((img, index) => {
                imageSelection += `${index + 1}. ${img}\\n`;
            });
            
            const selectedImage = prompt(imageSelection + '\\nEnter image filename (e.g., p2_2.png):');
            if (selectedImage && selectedImage.trim()) {
                const imageName = selectedImage.trim();
                const placeholder = `![${imageName}]`;
                
                // Insert at cursor position
                const start = textarea.selectionStart;
                const end = textarea.selectionEnd;
                const textBefore = textarea.value.substring(0, start);
                const textAfter = textarea.value.substring(end);
                
                textarea.value = textBefore + placeholder + textAfter;
                
                // Move cursor after the inserted placeholder
                textarea.selectionStart = textarea.selectionEnd = start + placeholder.length;
                textarea.focus();
                
                // Auto-resize textarea
                autoResizeTextarea(textarea);
                
                // Update the appropriate data based on context
                if (context === 'problem_solution') {
                    updateSolutionFromTextarea();
                } else if (context === 'problemText') {
                    updateProblem('problem_text', textarea.value);
                } else if (context === 'subproblemSolution') {
                    updateSubproblemSolution(key, textarea.value);
                }
            }
        }

        // Image removal functions
        function removeImageFromContext(context, imageIndex) {
            if (currentProblemIndex < 0) {
                alert('No problem selected');
                return;
            }
            
            const problem = problemsData.problems[currentProblemIndex];
            let imageArray;
            let imageFileName;
            
            // Determine which image array to modify based on context
            switch (context) {
                case 'problem':
                    imageArray = problem.images;
                    break;
                case 'problem_solution':
                    if (problem.solution && problem.solution.images) {
                        imageArray = problem.solution.images;
                    }
                    break;
                default:
                    console.error('Unknown context:', context);
                    return;
            }
            
            if (!imageArray || imageIndex < 0 || imageIndex >= imageArray.length) {
                alert('Invalid image index');
                return;
            }
            
            imageFileName = imageArray[imageIndex];
            
            // Show confirmation dialog
            if (confirm(`Remove image "${imageFileName}" from the JSON?\n\nNote: This only removes the reference from the JSON file. You will need to manually delete the actual image file.`)) {
                // Remove image from array
                imageArray.splice(imageIndex, 1);
                
                // Refresh the display
                refreshImageDisplay(context);
                
                showSuccess(`Image "${imageFileName}" removed from JSON successfully!`);
            }
        }

        function removeImageFromSubproblem(subproblemKey, imageIndex) {
            if (currentProblemIndex < 0) {
                alert('No problem selected');
                return;
            }
            
            const problem = problemsData.problems[currentProblemIndex];
            
            if (!problem.subproblems || !problem.subproblems[subproblemKey] || !problem.subproblems[subproblemKey].images) {
                alert('No images found for this subproblem');
                return;
            }
            
            const imageArray = problem.subproblems[subproblemKey].images;
            
            if (imageIndex < 0 || imageIndex >= imageArray.length) {
                alert('Invalid image index');
                return;
            }
            
            const imageFileName = imageArray[imageIndex];
            
            // Show confirmation dialog
            if (confirm(`Remove image "${imageFileName}" from subproblem ${subproblemKey}?\n\nNote: This only removes the reference from the JSON file. You will need to manually delete the actual image file.`)) {
                // Remove image from array
                imageArray.splice(imageIndex, 1);
                
                // Refresh the subproblems section
                refreshSubproblemsSection();
                
                showSuccess(`Image "${imageFileName}" removed from subproblem ${subproblemKey} successfully!`);
            }
        }

        function refreshImageDisplay(context) {
            const problem = problemsData.problems[currentProblemIndex];
            
            switch (context) {
                case 'problem':
                    // Refresh main problem images
                    const mainImageContainer = document.getElementById('problemImage');
                    if (mainImageContainer && problem.images && problem.images.length > 0) {
                        mainImageContainer.innerHTML = generateImageSection(problem.images, 'problem');
                    } else if (mainImageContainer) {
                        // Hide the entire images section if no images left
                        const imagesFormGroup = mainImageContainer.closest('.form-group');
                        if (imagesFormGroup) {
                            imagesFormGroup.style.display = 'none';
                        }
                    }
                    break;
                    
                case 'problem_solution':
                    // Refresh solution images - need to find and update the solution images section
                    const solutionImagesContainer = document.querySelector('.form-group .problem-image');
                    if (solutionImagesContainer && problem.solution && problem.solution.images && problem.solution.images.length > 0) {
                        // Find the solution images container specifically
                        const solutionLabel = document.querySelector('label[style*="font-size: 12px"]:not([style*="text-align"])');
                        if (solutionLabel && solutionLabel.textContent.includes('Solution Images')) {
                            const container = solutionLabel.closest('.form-group').querySelector('.problem-image');
                            if (container) {
                                container.innerHTML = generateImageSection(problem.solution.images, 'problem_solution');
                            }
                        }
                    } else {
                        // Hide the solution images section if no images left
                        const solutionLabel = document.querySelector('label[style*="font-size: 12px"]:not([style*="text-align"])');
                        if (solutionLabel && solutionLabel.textContent.includes('Solution Images')) {
                            const formGroup = solutionLabel.closest('.form-group');
                            if (formGroup) {
                                formGroup.style.display = 'none';
                            }
                        }
                    }
                    break;
            }
        }

        // Helper functions for hints
        function formatHintsForDisplay(hints) {
            if (!hints || hints.length === 0) {
                return '';
            }
            // Join hints with line breaks for display
            return hints.join('<br>');
        }

        function formatHintsForEdit(hints) {
            if (!hints || hints.length === 0) {
                return '';
            }
            // Join hints with newlines for editing
            return hints.join('\n');
        }

        // Generate hints section with individual boxes
        function generateHintsSection(hints) {
            if (!hints || hints.length === 0) {
                hints = [''];  // Start with one empty hint
            }
            
            return hints.map((hint, index) => `
                <div class="hint-item" style="margin-bottom: 15px; position: relative;">
                    <div class="hint-display" id="hintDisplay_${index}" style="${hint ? '' : 'display: none;'}">
                        <div class="problem-text-display" style="cursor: pointer;" onclick="toggleHintEdit(${index})">
                            <div id="hintRendered_${index}">${preprocessLatexLists(hint || '')}</div>
                        </div>
                    </div>
                    <div class="hint-edit" id="hintEdit_${index}" style="${hint ? 'display: none;' : ''}">
                        <input type="text" class="form-control" id="hintInput_${index}" onblur="saveHintEdit(${index})" value="${hint ? hint.replace(/"/g, '&quot;') : ''}" placeholder="Enter a hint..." style="width: 100%; padding: 15px; min-height: 60px; border: 2px solid #e9ecef; border-radius: 8px;">
                    </div>
                    <button class="btn" onclick="removeHint(${index})" type="button" style="position: absolute; top: -20px; right: 0px; background: #dc3545; color: white; font-size: 12px; padding: 4px 8px; border: none; border-radius: 4px; z-index: 10;">Remove</button>
                </div>
            `).join('');
        }

        // Main problem hint functions
        function addHint() {
            if (currentProblemIndex >= 0) {
                if (!problemsData.problems[currentProblemIndex].hint) {
                    problemsData.problems[currentProblemIndex].hint = [];
                }
                problemsData.problems[currentProblemIndex].hint.push('');
                refreshHintsSection();
            }
        }

        function removeHint(index) {
            if (currentProblemIndex >= 0 && problemsData.problems[currentProblemIndex].hint) {
                problemsData.problems[currentProblemIndex].hint.splice(index, 1);
                refreshHintsSection();
            }
        }

        function updateHintAtIndex(index, value) {
            if (currentProblemIndex >= 0 && problemsData.problems[currentProblemIndex].hint) {
                problemsData.problems[currentProblemIndex].hint[index] = value;
            }
        }

        function refreshHintsSection() {
            const hintsContainer = document.getElementById('hintsContainer');
            const hints = problemsData.problems[currentProblemIndex].hint || [];
            hintsContainer.innerHTML = generateHintsSection(hints);
            
            // Re-render LaTeX for all hint displays
            if (window.MathJax) {
                const elements = [];
                hints.forEach((_, index) => {
                    const elem = document.getElementById(`hintRendered_${index}`);
                    if (elem) elements.push(elem);
                });
                if (elements.length > 0) {
                    MathJax.typesetPromise(elements);
                }
            }
        }

        function toggleHintEdit(index) {
            const display = document.getElementById(`hintDisplay_${index}`);
            const edit = document.getElementById(`hintEdit_${index}`);
            const input = document.getElementById(`hintInput_${index}`);
            
            // Switch to edit mode
            display.style.display = 'none';
            edit.style.display = 'block';
            input.focus();
            input.select();
        }

        function saveHintEdit(index) {
            const input = document.getElementById(`hintInput_${index}`);
            const display = document.getElementById(`hintDisplay_${index}`);
            const edit = document.getElementById(`hintEdit_${index}`);
            const rendered = document.getElementById(`hintRendered_${index}`);
            
            const newValue = input.value.trim();
            
            // Update the data
            updateHintAtIndex(index, newValue);
            
            // Update the display
            if (newValue) {
                rendered.innerHTML = preprocessLatexLists(newValue);
                display.style.display = 'block';
                edit.style.display = 'none';
                
                // Re-render LaTeX
                if (window.MathJax) {
                    MathJax.typesetPromise([rendered]);
                }
            } else {
                // If empty, stay in edit mode
                display.style.display = 'none';
                edit.style.display = 'block';
            }
        }

        function updateHint(hintsArray) {
            if (currentProblemIndex >= 0) {
                problemsData.problems[currentProblemIndex].hint = hintsArray;
            }
        }

        // NEW: Single-value hint functions
        function generateHintSection(hint) {
            const hintText = hint || '';
            return `
                <div class="hint-item" style="margin-bottom: 15px; position: relative;">
                    <div class="hint-display" id="hintDisplay_single" style="${hintText ? '' : 'display: none;'}">
                        <div class="problem-text-display" style="cursor: pointer;" onclick="toggleSingleHintEdit()">
                            <div id="hintRendered_single">${preprocessLatexLists(hintText)}</div>
                        </div>
                    </div>
                    <div class="hint-edit" id="hintEdit_single" style="${hintText ? 'display: none;' : ''}">
                        <input type="text" class="form-control" id="hintInput_single" onblur="saveSingleHintEdit()" value="${hintText ? hintText.replace(/"/g, '&quot;') : ''}" placeholder="Enter a hint..." style="width: 100%; padding: 15px; min-height: 60px; border: 2px solid #e9ecef; border-radius: 8px;">
                    </div>
                </div>
            `;
        }

        function toggleSingleHintEdit() {
            const display = document.getElementById('hintDisplay_single');
            const edit = document.getElementById('hintEdit_single');
            const input = document.getElementById('hintInput_single');
            
            display.style.display = 'none';
            edit.style.display = 'block';
            input.focus();
            input.select();
        }

        function saveSingleHintEdit() {
            const input = document.getElementById('hintInput_single');
            const display = document.getElementById('hintDisplay_single');
            const edit = document.getElementById('hintEdit_single');
            const rendered = document.getElementById('hintRendered_single');
            
            const newValue = input.value.trim();
            
            // Update the data
            if (currentProblemIndex >= 0) {
                problemsData.problems[currentProblemIndex].hint = newValue || null;
            }
            
            // Update the display
            if (newValue) {
                rendered.innerHTML = preprocessLatexLists(newValue);
                display.style.display = 'block';
                edit.style.display = 'none';
                
                // Re-render LaTeX
                if (window.MathJax) {
                    MathJax.typesetPromise([rendered]);
                }
            } else {
                display.style.display = 'none';
                edit.style.display = 'block';
            }
        }

        // NEW: Single-value solution functions
        function generateSolutionSection(solution) {
            let solutionText = '';
            if (solution) {
                if (typeof solution === 'string') {
                    solutionText = solution;
                } else if (solution.text) {
                    solutionText = solution.text || '';
                }
            }
            
            return `
                <div class="solution-item" style="margin-bottom: 15px; position: relative;">
                    <div class="solution-display" id="solutionDisplay_single" style="${solutionText ? '' : 'display: none;'}">
                        <div class="problem-text-display" style="cursor: pointer;" onclick="toggleSingleSolutionEdit()">
                            <div id="solutionRendered_single">${preprocessLatexLists(solutionText)}</div>
                        </div>
                    </div>
                    <div class="solution-edit" id="solutionEdit_single" style="${solutionText ? 'display: none;' : ''}">
                        <textarea class="form-control" id="solutionTextarea_single" onblur="saveSingleSolutionEdit()" style="width: 100%; min-height: 100px; resize: vertical; padding: 15px; border: 2px solid #e9ecef; border-radius: 8px;" placeholder="Enter a solution...">${solutionText ? solutionText.replace(/"/g, '&quot;') : ''}</textarea>
                    </div>
                    
                    <!-- Solution Image Upload Section (Always Visible) -->
                    <div class="solution-image-upload" style="margin-top: 10px; padding: 10px; background: #f8f9fa; border-radius: 8px;">
                        <label style="font-size: 12px; color: #6c757d; margin-bottom: 5px; display: block;">Solution Images</label>
                        <input type="file" id="solutionImageUpload" multiple accept="image/*" style="display: none;" onchange="handleSolutionImageUpload(event)">
                        <button type="button" class="btn btn-sm" onclick="triggerSolutionImageUpload()" style="background: #17a2b8; color: white; font-size: 12px; padding: 6px 12px;">
                            📷 Upload Images
                        </button>
                        <div id="solutionImagePreview" style="margin-top: 10px;">
                            ${generateSolutionImagePreview(solution)}
                        </div>
                    </div>
                </div>
            `;
        }

        function toggleSingleSolutionEdit() {
            const display = document.getElementById('solutionDisplay_single');
            const edit = document.getElementById('solutionEdit_single');
            const textarea = document.getElementById('solutionTextarea_single');
            
            display.style.display = 'none';
            edit.style.display = 'block';
            textarea.focus();
        }

        function saveSingleSolutionEdit() {
            const textarea = document.getElementById('solutionTextarea_single');
            const display = document.getElementById('solutionDisplay_single');
            const edit = document.getElementById('solutionEdit_single');
            const rendered = document.getElementById('solutionRendered_single');
            
            const newValue = textarea.value.trim();
            
            // Update the data
            if (currentProblemIndex >= 0) {
                if (!problemsData.problems[currentProblemIndex].solution) {
                    problemsData.problems[currentProblemIndex].solution = { text: null, images: [] };
                }
                problemsData.problems[currentProblemIndex].solution.text = newValue || null;
            }
            
            // Update the display
            if (newValue) {
                rendered.innerHTML = preprocessLatexLists(newValue);
                display.style.display = 'block';
                edit.style.display = 'none';
                
                // Re-render LaTeX
                if (window.MathJax) {
                    MathJax.typesetPromise([rendered]);
                }
            } else {
                display.style.display = 'none';
                edit.style.display = 'block';
            }
        }

        // Generate solutions section with individual boxes
        function generateSolutionsSection(solution) {
            // Handle different solution formats: null, string, object with text, object with array
            let solutions = [];
            if (solution) {
                if (typeof solution === 'string') {
                    solutions = solution ? [solution] : [];
                } else if (solution.text) {
                    if (Array.isArray(solution.text)) {
                        solutions = solution.text;
                    } else {
                        solutions = solution.text ? [solution.text] : [];
                    }
                } else if (Array.isArray(solution)) {
                    solutions = solution;
                }
            }
            
            if (solutions.length === 0) {
                solutions = [''];  // Start with one empty solution
            }
            
            return solutions.map((sol, index) => `
                <div class="solution-item" style="margin-bottom: 15px; position: relative;">
                    <div class="solution-display" id="solutionDisplay_${index}" style="${sol ? '' : 'display: none;'}">
                        <div class="problem-text-display" style="cursor: pointer;" onclick="toggleSolutionEdit(${index})">
                            <div id="solutionRendered_${index}">${preprocessLatexLists(sol || '')}</div>
                        </div>
                    </div>
                    <div class="solution-edit" id="solutionEdit_${index}" style="${sol ? 'display: none;' : ''}">
                        <textarea class="form-control" id="solutionTextarea_${index}" onblur="saveSolutionEdit(${index})" style="width: 100%; min-height: 100px; resize: vertical; padding: 15px; border: 2px solid #e9ecef; border-radius: 8px;" placeholder="Enter a solution...">${sol ? sol.replace(/"/g, '&quot;') : ''}</textarea>
                    </div>
                    <button class="btn" onclick="removeSolution(${index})" type="button" style="position: absolute; top: -20px; right: 0px; background: #dc3545; color: white; font-size: 12px; padding: 4px 8px; border: none; border-radius: 4px; z-index: 10;">Remove</button>
                </div>
            `).join('');
        }

        // Main problem solution functions
        function addSolution() {
            if (currentProblemIndex >= 0) {
                let problem = problemsData.problems[currentProblemIndex];
                
                // Initialize solution structure
                if (!problem.solution) {
                    problem.solution = { text: [], images: [] };
                } else if (typeof problem.solution === 'string') {
                    // Convert string to array format
                    problem.solution = { 
                        text: problem.solution ? [problem.solution] : [], 
                        images: [] 
                    };
                } else if (problem.solution.text && !Array.isArray(problem.solution.text)) {
                    // Convert single text to array
                    problem.solution.text = problem.solution.text ? [problem.solution.text] : [];
                }
                
                if (!Array.isArray(problem.solution.text)) {
                    problem.solution.text = [];
                }
                
                problem.solution.text.push('');
                refreshSolutionsSection();
            }
        }

        function removeSolution(index) {
            if (currentProblemIndex >= 0) {
                let problem = problemsData.problems[currentProblemIndex];
                if (problem.solution && problem.solution.text && Array.isArray(problem.solution.text)) {
                    problem.solution.text.splice(index, 1);
                    refreshSolutionsSection();
                }
            }
        }

        function updateSolutionAtIndex(index, value) {
            if (currentProblemIndex >= 0) {
                let problem = problemsData.problems[currentProblemIndex];
                if (problem.solution && problem.solution.text && Array.isArray(problem.solution.text)) {
                    problem.solution.text[index] = value;
                }
            }
        }

        function refreshSolutionsSection() {
            const solutionsContainer = document.getElementById('solutionsContainer');
            const solution = problemsData.problems[currentProblemIndex].solution;
            solutionsContainer.innerHTML = generateSolutionsSection(solution);
            
            // Re-render LaTeX for all solution displays
            if (window.MathJax) {
                const elements = [];
                let solutions = [];
                if (solution) {
                    if (typeof solution === 'string') {
                        solutions = [solution];
                    } else if (solution.text) {
                        solutions = Array.isArray(solution.text) ? solution.text : [solution.text];
                    }
                }
                solutions.forEach((_, index) => {
                    const elem = document.getElementById(`solutionRendered_${index}`);
                    if (elem) elements.push(elem);
                });
                if (elements.length > 0) {
                    MathJax.typesetPromise(elements);
                }
            }
        }

        function toggleSolutionEdit(index) {
            const display = document.getElementById(`solutionDisplay_${index}`);
            const edit = document.getElementById(`solutionEdit_${index}`);
            const textarea = document.getElementById(`solutionTextarea_${index}`);
            
            // Switch to edit mode
            display.style.display = 'none';
            edit.style.display = 'block';
            textarea.focus();
            autoResizeTextarea(textarea);
        }

        function saveSolutionEdit(index) {
            const textarea = document.getElementById(`solutionTextarea_${index}`);
            const display = document.getElementById(`solutionDisplay_${index}`);
            const edit = document.getElementById(`solutionEdit_${index}`);
            const rendered = document.getElementById(`solutionRendered_${index}`);
            
            const newValue = textarea.value.trim();
            
            // Update the data
            updateSolutionAtIndex(index, newValue);
            
            // Update the display
            if (newValue) {
                rendered.innerHTML = preprocessLatexLists(newValue);
                display.style.display = 'block';
                edit.style.display = 'none';
                
                // Re-render LaTeX
                if (window.MathJax) {
                    MathJax.typesetPromise([rendered]);
                }
            } else {
                // If empty, stay in edit mode
                display.style.display = 'none';
                edit.style.display = 'block';
            }
        }

        // Generate subproblem solutions section with individual boxes
        function generateSubproblemSolutionsSection(solution, subproblemKey) {
            // Handle different solution formats: null, string, object with text, object with array
            let solutions = [];
            if (solution) {
                if (typeof solution === 'string') {
                    solutions = solution ? [solution] : [];
                } else if (solution.text) {
                    if (Array.isArray(solution.text)) {
                        solutions = solution.text;
                    } else {
                        solutions = solution.text ? [solution.text] : [];
                    }
                } else if (Array.isArray(solution)) {
                    solutions = solution;
                }
            }
            
            if (solutions.length === 0) {
                solutions = [''];  // Start with one empty solution
            }
            
            return solutions.map((sol, index) => `
                <div class="solution-item" style="margin-bottom: 10px; position: relative;">
                    <div class="solution-display" id="subSolutionDisplay_${subproblemKey}_${index}" style="${sol ? '' : 'display: none;'}">
                        <div class="problem-text-display" style="cursor: pointer; font-size: 12px; min-height: 80px;" onclick="toggleSubproblemSolutionEdit('${subproblemKey}', ${index})">
                            <div id="subSolutionRendered_${subproblemKey}_${index}">${preprocessLatexLists(sol || '')}</div>
                        </div>
                    </div>
                    <div class="solution-edit" id="subSolutionEdit_${subproblemKey}_${index}" style="${sol ? 'display: none;' : ''}">
                        <textarea class="form-control" id="subSolutionTextarea_${subproblemKey}_${index}" onblur="saveSubproblemSolutionEdit('${subproblemKey}', ${index})" style="width: 100%; min-height: 80px; resize: vertical; font-size: 12px; padding: 12px; border: 2px solid #e9ecef; border-radius: 8px;" placeholder="Enter a solution...">${sol ? sol.replace(/"/g, '&quot;') : ''}</textarea>
                    </div>
                    <button class="btn" onclick="removeSubproblemSolution('${subproblemKey}', ${index})" type="button" style="position: absolute; top: -20px; right: 0px; background: #dc3545; color: white; font-size: 12px; padding: 4px 8px; border: none; border-radius: 4px; z-index: 10;">Remove</button>
                </div>
            `).join('');
        }

        // Subproblem solution functions
        function addSubproblemSolution(key) {
            if (currentProblemIndex >= 0) {
                if (!problemsData.problems[currentProblemIndex].subproblems) {
                    problemsData.problems[currentProblemIndex].subproblems = {};
                }
                if (!problemsData.problems[currentProblemIndex].subproblems[key]) {
                    problemsData.problems[currentProblemIndex].subproblems[key] = {
                        problem_text: '',
                        correct_answer: '',
                        hint: [],
                        solution: { text: [], images: [] },
                        images: []
                    };
                }
                
                let subproblemSolution = problemsData.problems[currentProblemIndex].subproblems[key].solution;
                
                // Initialize solution structure
                if (!subproblemSolution) {
                    subproblemSolution = { text: [], images: [] };
                    problemsData.problems[currentProblemIndex].subproblems[key].solution = subproblemSolution;
                } else if (typeof subproblemSolution === 'string') {
                    // Convert string to array format
                    subproblemSolution = { 
                        text: subproblemSolution ? [subproblemSolution] : [], 
                        images: [] 
                    };
                    problemsData.problems[currentProblemIndex].subproblems[key].solution = subproblemSolution;
                } else if (subproblemSolution.text && !Array.isArray(subproblemSolution.text)) {
                    // Convert single text to array
                    subproblemSolution.text = subproblemSolution.text ? [subproblemSolution.text] : [];
                }
                
                if (!Array.isArray(subproblemSolution.text)) {
                    subproblemSolution.text = [];
                }
                
                subproblemSolution.text.push('');
                refreshSubproblemSolutionsSection(key);
            }
        }

        function removeSubproblemSolution(key, index) {
            if (currentProblemIndex >= 0) {
                const subproblem = problemsData.problems[currentProblemIndex].subproblems?.[key];
                if (subproblem && subproblem.solution && subproblem.solution.text && Array.isArray(subproblem.solution.text)) {
                    subproblem.solution.text.splice(index, 1);
                    refreshSubproblemSolutionsSection(key);
                }
            }
        }

        function updateSubproblemSolutionAtIndex(key, index, value) {
            if (currentProblemIndex >= 0) {
                const subproblem = problemsData.problems[currentProblemIndex].subproblems?.[key];
                if (subproblem && subproblem.solution && subproblem.solution.text && Array.isArray(subproblem.solution.text)) {
                    subproblem.solution.text[index] = value;
                }
            }
        }

        function refreshSubproblemSolutionsSection(key) {
            const solutionsContainer = document.getElementById(`subproblemSolutionsContainer_${key}`);
            const subproblem = problemsData.problems[currentProblemIndex].subproblems?.[key];
            const solution = subproblem ? subproblem.solution : null;
            solutionsContainer.innerHTML = generateSubproblemSolutionsSection(solution, key);
            
            // Re-render LaTeX for all solution displays
            if (window.MathJax) {
                const elements = [];
                let solutions = [];
                if (solution) {
                    if (typeof solution === 'string') {
                        solutions = [solution];
                    } else if (solution && solution.text) {
                        solutions = Array.isArray(solution.text) ? solution.text : [solution.text];
                    }
                }
                solutions.forEach((_, index) => {
                    const elem = document.getElementById(`subSolutionRendered_${key}_${index}`);
                    if (elem) elements.push(elem);
                });
                if (elements.length > 0) {
                    MathJax.typesetPromise(elements);
                }
            }
        }

        function toggleSubproblemSolutionEdit(key, index) {
            const display = document.getElementById(`subSolutionDisplay_${key}_${index}`);
            const edit = document.getElementById(`subSolutionEdit_${key}_${index}`);
            const textarea = document.getElementById(`subSolutionTextarea_${key}_${index}`);
            
            // Switch to edit mode
            display.style.display = 'none';
            edit.style.display = 'block';
            textarea.focus();
            autoResizeTextarea(textarea);
        }

        function saveSubproblemSolutionEdit(key, index) {
            const textarea = document.getElementById(`subSolutionTextarea_${key}_${index}`);
            const display = document.getElementById(`subSolutionDisplay_${key}_${index}`);
            const edit = document.getElementById(`subSolutionEdit_${key}_${index}`);
            const rendered = document.getElementById(`subSolutionRendered_${key}_${index}`);
            
            const newValue = textarea.value.trim();
            
            // Update the data
            updateSubproblemSolutionAtIndex(key, index, newValue);
            
            // Update the display
            if (newValue) {
                rendered.innerHTML = preprocessLatexLists(newValue);
                display.style.display = 'block';
                edit.style.display = 'none';
                
                // Re-render LaTeX
                if (window.MathJax) {
                    MathJax.typesetPromise([rendered]);
                }
            } else {
                // If empty, stay in edit mode
                display.style.display = 'none';
                edit.style.display = 'block';
            }
        }

        // Generate subproblem hints section with individual boxes
        function generateSubproblemHintsSection(hints, subproblemKey) {
            if (!hints || hints.length === 0) {
                hints = [''];  // Start with one empty hint
            }
            
            return hints.map((hint, index) => `
                <div class="hint-item" style="margin-bottom: 10px; position: relative;">
                    <div class="hint-display" id="subHintDisplay_${subproblemKey}_${index}" style="${hint ? '' : 'display: none;'}">
                        <div class="problem-text-display" style="cursor: pointer; font-size: 12px; min-height: 60px;" onclick="toggleSubproblemHintEdit('${subproblemKey}', ${index})">
                            <div id="subHintRendered_${subproblemKey}_${index}">${preprocessLatexLists(hint || '')}</div>
                        </div>
                    </div>
                    <div class="hint-edit" id="subHintEdit_${subproblemKey}_${index}" style="${hint ? 'display: none;' : ''}">
                        <input type="text" class="form-control" id="subHintInput_${subproblemKey}_${index}" onblur="saveSubproblemHintEdit('${subproblemKey}', ${index})" value="${hint ? hint.replace(/"/g, '&quot;') : ''}" placeholder="Enter a hint..." style="width: 100%; font-size: 12px; padding: 12px; min-height: 60px; border: 2px solid #e9ecef; border-radius: 8px;">
                    </div>
                    <button class="btn" onclick="removeSubproblemHint('${subproblemKey}', ${index})" type="button" style="position: absolute; top: -20px; right: 0px; background: #dc3545; color: white; font-size: 12px; padding: 4px 8px; border: none; border-radius: 4px; z-index: 10;">Remove</button>
                </div>
            `).join('');
        }

        // Subproblem hint functions
        function addSubproblemHint(key) {
            if (currentProblemIndex >= 0) {
                if (!problemsData.problems[currentProblemIndex].subproblems) {
                    problemsData.problems[currentProblemIndex].subproblems = {};
                }
                if (!problemsData.problems[currentProblemIndex].subproblems[key]) {
                    problemsData.problems[currentProblemIndex].subproblems[key] = {
                        problem_text: '',
                        correct_answer: '',
                        hint: [],
                        solution: null,
                        images: []
                    };
                }
                if (!problemsData.problems[currentProblemIndex].subproblems[key].hint) {
                    problemsData.problems[currentProblemIndex].subproblems[key].hint = [];
                }
                problemsData.problems[currentProblemIndex].subproblems[key].hint.push('');
                refreshSubproblemHintsSection(key);
            }
        }

        function removeSubproblemHint(key, index) {
            if (currentProblemIndex >= 0 && problemsData.problems[currentProblemIndex].subproblems && 
                problemsData.problems[currentProblemIndex].subproblems[key] && 
                problemsData.problems[currentProblemIndex].subproblems[key].hint) {
                problemsData.problems[currentProblemIndex].subproblems[key].hint.splice(index, 1);
                refreshSubproblemHintsSection(key);
            }
        }

        function updateSubproblemHintAtIndex(key, index, value) {
            if (currentProblemIndex >= 0 && problemsData.problems[currentProblemIndex].subproblems && 
                problemsData.problems[currentProblemIndex].subproblems[key] && 
                problemsData.problems[currentProblemIndex].subproblems[key].hint) {
                problemsData.problems[currentProblemIndex].subproblems[key].hint[index] = value;
            }
        }

        function refreshSubproblemHintsSection(key) {
            const hintsContainer = document.getElementById(`subproblemHintsContainer_${key}`);
            const hints = (problemsData.problems[currentProblemIndex].subproblems && 
                          problemsData.problems[currentProblemIndex].subproblems[key] && 
                          problemsData.problems[currentProblemIndex].subproblems[key].hint) || [];
            hintsContainer.innerHTML = generateSubproblemHintsSection(hints, key);
            
            // Re-render LaTeX for all hint displays
            if (window.MathJax) {
                const elements = [];
                hints.forEach((_, index) => {
                    const elem = document.getElementById(`subHintRendered_${key}_${index}`);
                    if (elem) elements.push(elem);
                });
                if (elements.length > 0) {
                    MathJax.typesetPromise(elements);
                }
            }
        }

        function toggleSubproblemHintEdit(key, index) {
            const display = document.getElementById(`subHintDisplay_${key}_${index}`);
            const edit = document.getElementById(`subHintEdit_${key}_${index}`);
            const input = document.getElementById(`subHintInput_${key}_${index}`);
            
            // Switch to edit mode
            display.style.display = 'none';
            edit.style.display = 'block';
            input.focus();
            input.select();
        }

        function saveSubproblemHintEdit(key, index) {
            const input = document.getElementById(`subHintInput_${key}_${index}`);
            const display = document.getElementById(`subHintDisplay_${key}_${index}`);
            const edit = document.getElementById(`subHintEdit_${key}_${index}`);
            const rendered = document.getElementById(`subHintRendered_${key}_${index}`);
            
            const newValue = input.value.trim();
            
            // Update the data
            updateSubproblemHintAtIndex(key, index, newValue);
            
            // Update the display
            if (newValue) {
                rendered.innerHTML = preprocessLatexLists(newValue);
                display.style.display = 'block';
                edit.style.display = 'none';
                
                // Re-render LaTeX
                if (window.MathJax) {
                    MathJax.typesetPromise([rendered]);
                }
            } else {
                // If empty, stay in edit mode
                display.style.display = 'none';
                edit.style.display = 'block';
            }
        }

        function updateSubproblemHintArray(key, hintsArray) {
            if (currentProblemIndex >= 0) {
                if (!problemsData.problems[currentProblemIndex].subproblems) {
                    problemsData.problems[currentProblemIndex].subproblems = {};
                }
                if (!problemsData.problems[currentProblemIndex].subproblems[key]) {
                    problemsData.problems[currentProblemIndex].subproblems[key] = {
                        problem_text: '',
                        correct_answer: '',
                        hint: [],
                        solution: null,
                        images: []
                    };
                }
                problemsData.problems[currentProblemIndex].subproblems[key].hint = hintsArray;
            }
        }

        // NEW: Single-value subproblem hint functions
        function generateSubproblemHintSection(hint, subproblemKey) {
            const hintText = hint || '';
            return `
                <div class="hint-item" style="margin-bottom: 15px; position: relative;">
                    <div class="hint-display" id="subHintDisplay_${subproblemKey}_single" style="${hintText ? '' : 'display: none;'}">
                        <div class="problem-text-display" style="cursor: pointer;" onclick="toggleSubproblemSingleHintEdit('${subproblemKey}')">
                            <div id="subHintRendered_${subproblemKey}_single">${preprocessLatexLists(hintText)}</div>
                        </div>
                    </div>
                    <div class="hint-edit" id="subHintEdit_${subproblemKey}_single" style="${hintText ? 'display: none;' : ''}">
                        <input type="text" class="form-control" id="subHintInput_${subproblemKey}_single" onblur="saveSubproblemSingleHintEdit('${subproblemKey}')" value="${hintText ? hintText.replace(/"/g, '&quot;') : ''}" placeholder="Enter a hint..." style="width: 100%; padding: 12px; min-height: 50px; border: 2px solid #e9ecef; border-radius: 8px; font-size: 12px;">
                    </div>
                </div>
            `;
        }

        function toggleSubproblemSingleHintEdit(key) {
            const display = document.getElementById(`subHintDisplay_${key}_single`);
            const edit = document.getElementById(`subHintEdit_${key}_single`);
            const input = document.getElementById(`subHintInput_${key}_single`);
            
            display.style.display = 'none';
            edit.style.display = 'block';
            input.focus();
            input.select();
        }

        function saveSubproblemSingleHintEdit(key) {
            const input = document.getElementById(`subHintInput_${key}_single`);
            const display = document.getElementById(`subHintDisplay_${key}_single`);
            const edit = document.getElementById(`subHintEdit_${key}_single`);
            const rendered = document.getElementById(`subHintRendered_${key}_single`);
            
            const newValue = input.value.trim();
            
            // Update the data
            if (currentProblemIndex >= 0) {
                if (!problemsData.problems[currentProblemIndex].subproblems) {
                    problemsData.problems[currentProblemIndex].subproblems = {};
                }
                if (!problemsData.problems[currentProblemIndex].subproblems[key]) {
                    problemsData.problems[currentProblemIndex].subproblems[key] = {
                        problem_text: '',
                        correct_answer: '',
                        hint: null,
                        solution: { text: null, images: [] },
                        images: []
                    };
                }
                problemsData.problems[currentProblemIndex].subproblems[key].hint = newValue || null;
            }
            
            // Update the display
            if (newValue) {
                rendered.innerHTML = preprocessLatexLists(newValue);
                display.style.display = 'block';
                edit.style.display = 'none';
                
                // Re-render LaTeX
                if (window.MathJax) {
                    MathJax.typesetPromise([rendered]);
                }
            } else {
                display.style.display = 'none';
                edit.style.display = 'block';
            }
        }

        // NEW: Single-value subproblem solution functions
        function generateSubproblemSolutionSection(solution, subproblemKey) {
            let solutionText = '';
            if (solution) {
                if (typeof solution === 'string') {
                    solutionText = solution;
                } else if (solution.text) {
                    solutionText = solution.text || '';
                }
            }
            
            return `
                <div class="solution-item" style="margin-bottom: 15px; position: relative;">
                    <div class="solution-display" id="subSolutionDisplay_${subproblemKey}_single" style="${solutionText ? '' : 'display: none;'}">
                        <div class="problem-text-display" style="cursor: pointer;" onclick="toggleSubproblemSingleSolutionEdit('${subproblemKey}')">
                            <div id="subSolutionRendered_${subproblemKey}_single">${preprocessLatexLists(solutionText)}</div>
                        </div>
                    </div>
                    <div class="solution-edit" id="subSolutionEdit_${subproblemKey}_single" style="${solutionText ? 'display: none;' : ''}">
                        <textarea class="form-control" id="subSolutionTextarea_${subproblemKey}_single" onblur="saveSubproblemSingleSolutionEdit('${subproblemKey}')" style="width: 100%; min-height: 80px; resize: vertical; font-size: 12px; padding: 12px; border: 2px solid #e9ecef; border-radius: 8px;" placeholder="Enter a solution...">${solutionText ? solutionText.replace(/"/g, '&quot;') : ''}</textarea>
                    </div>
                </div>
            `;
        }

        function toggleSubproblemSingleSolutionEdit(key) {
            const display = document.getElementById(`subSolutionDisplay_${key}_single`);
            const edit = document.getElementById(`subSolutionEdit_${key}_single`);
            const textarea = document.getElementById(`subSolutionTextarea_${key}_single`);
            
            display.style.display = 'none';
            edit.style.display = 'block';
            textarea.focus();
        }

        function saveSubproblemSingleSolutionEdit(key) {
            const textarea = document.getElementById(`subSolutionTextarea_${key}_single`);
            const display = document.getElementById(`subSolutionDisplay_${key}_single`);
            const edit = document.getElementById(`subSolutionEdit_${key}_single`);
            const rendered = document.getElementById(`subSolutionRendered_${key}_single`);
            
            const newValue = textarea.value.trim();
            
            // Update the data
            if (currentProblemIndex >= 0) {
                if (!problemsData.problems[currentProblemIndex].subproblems) {
                    problemsData.problems[currentProblemIndex].subproblems = {};
                }
                if (!problemsData.problems[currentProblemIndex].subproblems[key]) {
                    problemsData.problems[currentProblemIndex].subproblems[key] = {
                        problem_text: '',
                        correct_answer: '',
                        hint: null,
                        solution: { text: null, images: [] },
                        images: []
                    };
                }
                if (!problemsData.problems[currentProblemIndex].subproblems[key].solution) {
                    problemsData.problems[currentProblemIndex].subproblems[key].solution = { text: null, images: [] };
                }
                problemsData.problems[currentProblemIndex].subproblems[key].solution.text = newValue || null;
            }
            
            // Update the display
            if (newValue) {
                rendered.innerHTML = preprocessLatexLists(newValue);
                display.style.display = 'block';
                edit.style.display = 'none';
                
                // Re-render LaTeX
                if (window.MathJax) {
                    MathJax.typesetPromise([rendered]);
                }
            } else {
                display.style.display = 'none';
                edit.style.display = 'block';
            }
        }

        // ===== READ DATABASE FUNCTIONALITY =====
        let selectedDocumentId = null;
        let selectedTopic = null;
        let currentFilterMode = 'document'; // 'document' or 'topic'

        async function showReadDatabaseModal() {
            const modal = document.getElementById('readDatabaseModal');
            modal.style.display = 'block';
            await loadTopicsInModal();
            await setFilterMode('document'); // Start with document mode
        }

        function closeReadDatabaseModal() {
            const modal = document.getElementById('readDatabaseModal');
            modal.style.display = 'none';
            selectedDocumentId = null;
            selectedTopic = null;
            document.getElementById('loadDocumentBtn').disabled = true;
        }

        async function setFilterMode(mode) {
            currentFilterMode = mode;
            
            // Update button styles
            const documentBtn = document.getElementById('filterDocumentBtn');
            const topicBtn = document.getElementById('filterTopicBtn');
            const topicSelector = document.getElementById('topicSelector');
            
            if (mode === 'document') {
                documentBtn.className = 'btn btn-primary';
                topicBtn.className = 'btn btn-secondary';
                topicSelector.style.display = 'none';
                await loadDocumentList();
            } else {
                documentBtn.className = 'btn btn-secondary';
                topicBtn.className = 'btn btn-primary';
                topicSelector.style.display = 'block';
                document.getElementById('documentListContainer').innerHTML = '<div style="text-align: center; padding: 20px; color: #666;">Select a topic above to see relevant problems.</div>';
            }
            
            // Reset selections
            selectedDocumentId = null;
            selectedTopic = null;
            selectedTopicInSearch = null;
            
            // Clear topic search
            const searchInput = document.getElementById('topicSearchInput');
            const selectedDisplay = document.getElementById('selectedTopicDisplay');
            if (searchInput) searchInput.value = '';
            if (selectedDisplay) selectedDisplay.innerHTML = '';
            
            document.getElementById('loadDocumentBtn').disabled = true;
        }

        let allTopics = [];
        let selectedTopicInSearch = null;

        async function loadTopicsInModal() {
            try {
                const { data: topics, error } = await supabase
                    .from('topics')
                    .select('id, name')
                    .order('id'); // Order by ID to match editor ordering
                
                if (error) throw error;
                
                allTopics = topics;
                populateModalTopicDropdown(topics);
                
            } catch (error) {
                console.error('Error loading topics:', error);
            }
        }

        function populateModalTopicDropdown(topics) {
            const dropdown = document.getElementById('modalTopicDropdown');
            dropdown.innerHTML = '';
            
            topics.forEach(topic => {
                const option = document.createElement('div');
                option.className = 'topic-option';
                option.dataset.topicId = topic.id;
                option.onmousedown = (e) => {
                    e.preventDefault(); // Prevent blur event
                    selectTopicFromDropdown(topic.id, topic.name);
                };
                
                option.innerHTML = `
                    <span class="topic-option-id">${topic.id}.</span>
                    <span>${topic.name}</span>
                `;
                
                dropdown.appendChild(option);
            });
        }

        function filterTopicsInModal() {
            const searchInput = document.getElementById('modalTopicSearchInput');
            const query = searchInput.value.toLowerCase();
            
            if (query === '') {
                populateModalTopicDropdown(allTopics);
                return;
            }
            
            const filteredTopics = allTopics.filter(topic => 
                topic.name.toLowerCase().includes(query) || 
                topic.id.toString().includes(query)
            );
            
            populateModalTopicDropdown(filteredTopics);
            showModalTopicDropdown();
        }

        function showModalTopicDropdown() {
            const dropdown = document.getElementById('modalTopicDropdown');
            dropdown.style.display = 'block';
        }

        function hideModalTopicDropdown() {
            setTimeout(() => {
                const dropdown = document.getElementById('modalTopicDropdown');
                dropdown.style.display = 'none';
            }, 200); // Delay to allow click events
        }

        function selectTopicFromDropdown(topicId, topicName) {
            selectedTopicInSearch = topicId;
            const searchInput = document.getElementById('modalTopicSearchInput');
            const selectedDisplay = document.getElementById('selectedTopicDisplay');
            
            searchInput.value = topicName;
            selectedDisplay.innerHTML = `Selected: <strong>${topicId}. ${topicName}</strong>`;
            
            hideModalTopicDropdown();
            loadProblemsByTopic();
        }

        async function loadProblemsByTopic() {
            const topicId = selectedTopicInSearch;
            const container = document.getElementById('documentListContainer');
            
            if (!topicId) {
                container.innerHTML = '<div style="text-align: center; padding: 20px; color: #666;">Select a topic above to load relevant problems.</div>';
                selectedTopic = null;
                document.getElementById('loadDocumentBtn').disabled = true;
                return;
            }
            
            try {
                // Just check if problems exist for this topic
                const { data: problems, error } = await supabase
                    .from('problems')
                    .select('id')
                    .eq('topic_id', topicId)
                    .limit(1);
                
                if (error) throw error;
                
                if (problems && problems.length > 0) {
                    selectedTopic = topicId;
                    container.innerHTML = '<div style="text-align: center; padding: 20px; color: #28a745;">✓ Topic selected. Click "Load Problems" to load all related problems.</div>';
                    document.getElementById('loadDocumentBtn').innerHTML = 'Load Problems';
                    document.getElementById('loadDocumentBtn').disabled = false;
                } else {
                    container.innerHTML = '<div style="text-align: center; padding: 20px; color: #666;">No problems found for this topic.</div>';
                    selectedTopic = null;
                    document.getElementById('loadDocumentBtn').disabled = true;
                }
                
            } catch (error) {
                console.error('Error checking problems for topic:', error);
                container.innerHTML = '<div style="text-align: center; padding: 20px; color: #dc3545;">Error checking topic: ' + error.message + '</div>';
                selectedTopic = null;
                document.getElementById('loadDocumentBtn').disabled = true;
            }
        }

        async function loadDocumentList() {
            const container = document.getElementById('documentListContainer');
            
            try {
                // Query all documents from the database
                const { data: documents, error } = await supabase
                    .from('documents')
                    .select('id, document_id, school, course, problem_type, term, year, total_problems, created_at')
                    .order('created_at', { ascending: false });

                if (error) {
                    throw error;
                }

                if (documents && documents.length > 0) {
                    let html = '<div class="document-list">';
                    
                    documents.forEach(doc => {
                        html += `
                            <div class="document-item" data-document-id="${doc.document_id}" onclick="selectDocument('${doc.document_id}')">
                                <div class="document-title">${doc.document_id}</div>
                            </div>
                        `;
                    });
                    
                    html += '</div>';
                    container.innerHTML = html;
                } else {
                    container.innerHTML = '<div style="text-align: center; padding: 20px; color: #666;">No documents found in database.</div>';
                }
            } catch (error) {
                console.error('Error loading documents:', error);
                container.innerHTML = '<div style="text-align: center; padding: 20px; color: #dc3545;">Error loading documents: ' + error.message + '</div>';
            }
        }

        function selectDocument(documentId) {
            // Remove previous selection
            document.querySelectorAll('.document-item').forEach(item => {
                item.classList.remove('selected');
            });
            
            // Add selection to clicked item
            document.querySelector(`[data-document-id="${documentId}"]`).classList.add('selected');
            
            selectedDocumentId = documentId;
            selectedTopic = null; // Clear topic selection
            document.getElementById('loadDocumentBtn').disabled = false;
            document.getElementById('loadDocumentBtn').innerHTML = 'Load Problems';
        }

        function selectProblemInModal(problemId) {
            // Remove previous selection
            document.querySelectorAll('.document-item').forEach(item => {
                item.classList.remove('selected');
            });
            
            // Add selection to clicked item
            document.querySelector(`[data-problem-id="${problemId}"]`).classList.add('selected');
            
            selectedDocumentId = null; // Clear document selection
            document.getElementById('loadDocumentBtn').disabled = false;
        }

        async function loadSelectedItem() {
            if (currentFilterMode === 'document' && selectedDocumentId) {
                await loadSelectedDocument();
            } else if (currentFilterMode === 'topic' && selectedTopic) {
                await loadProblemsByTopicForEditing();
            } else {
                showError('Please make a selection first');
            }
        }

        async function loadSelectedDocument() {
            if (!selectedDocumentId) {
                showError('No document selected');
                return;
            }

            try {
                // Show loading state
                document.getElementById('loadDocumentBtn').innerHTML = '⏳ Loading...';
                document.getElementById('loadDocumentBtn').disabled = true;

                const documentData = await loadDocumentFromDatabase(selectedDocumentId);
                
                if (documentData) {
                    // Replace current data with loaded document
                    problemsData = documentData;
                    originalData = JSON.parse(JSON.stringify(documentData)); // Deep copy for change detection
                    
                    // Update UI
                    displayProblemsList();
                    updateStats();
                    
                    // Update file info
                    document.getElementById('fileInfo').textContent = `Loaded: ${selectedDocumentId}`;
                    currentFileName = selectedDocumentId;
                    originalFileName = selectedDocumentId;
                    dataSourceType = 'database'; // Mark as database source
                    
                    // Save to localStorage
                    localStorage.setItem('problemsData', JSON.stringify(problemsData));
                    localStorage.setItem('currentFileName', currentFileName);
                    localStorage.setItem('originalFileName', originalFileName);
                    
                    // Close modal
                    closeReadDatabaseModal();
                    
                    showSuccess('Document loaded successfully from database!');
                }
                
            } catch (error) {
                console.error('Error loading document:', error);
                showError('Error loading document: ' + error.message);
            } finally {
                // Restore button state
                document.getElementById('loadDocumentBtn').innerHTML = 'Load Problems';
                document.getElementById('loadDocumentBtn').disabled = false;
            }
        }

        async function loadDocumentFromDatabase(documentId) {
            try {
                // Get document metadata
                const { data: docData, error: docError } = await supabase
                    .from('documents')
                    .select('*')
                    .eq('document_id', documentId)
                    .single();

                if (docError) throw docError;

                // Get problems with topics
                const { data: problemsData, error: problemsError } = await supabase
                    .from('problems')
                    .select(`
                        id,
                        problem_id,
                        problem_text,
                        correct_answer,
                        hint,
                        solution_text,
                        math_approach,
                        reasoning_type,
                        topic_id,
                        difficulty,
                        importance,
                        comment,
                        version,
                        created_at,
                        updated_at,
                        topics:topic_id(name)
                    `)
                    .eq('document_id', docData.id)
                    .order('problem_id');

                if (problemsError) throw problemsError;

                // Get subproblems
                const problemIds = problemsData.map(p => p.id);
                let subproblemsData = [];
                
                if (problemIds.length > 0) {
                    const { data: subs, error: subError } = await supabase
                        .from('subproblems')
                        .select('*')
                        .in('problem_id', problemIds);
                    
                    if (subError) throw subError;
                    subproblemsData = subs || [];
                }

                // Transform to JSON format
                const problems = problemsData.map(problem => {
                    // Get subproblems for this problem
                    const subprobs = subproblemsData.filter(sub => sub.problem_id === problem.id);
                    const subproblemsObj = {};
                    
                    subprobs.forEach(sub => {
                        subproblemsObj[sub.key] = {
                            problem_text: sub.problem_text,
                            correct_answer: sub.correct_answer,
                            hint: sub.hint,
                            solution: {
                                text: sub.solution_text,
                                images: [] // Images are stored in Supabase storage, not database
                            },
                            images: [], // Will be populated from storage if needed
                            comment: sub.comment
                        };
                    });

                    // Get topic as array (convert single topic_id to array format expected by frontend)
                    const topics = problem.topics ? [problem.topic_id] : [];

                    return {
                        id: problem.problem_id,
                        doc_id: documentId,
                        problem_text: problem.problem_text,
                        subproblems: subproblemsObj,
                        correct_answer: problem.correct_answer,
                        hint: problem.hint,
                        solution: {
                            text: problem.solution_text,
                            images: [] // Images are stored in Supabase storage
                        },
                        images: [], // Images are stored in Supabase storage
                        difficulty: problem.difficulty,
                        topics: topics,
                        math_approach: problem.math_approach,
                        reasoning_type: problem.reasoning_type,
                        comment: problem.comment,
                        importance: problem.importance,
                        updated_at: problem.updated_at,
                        version: problem.version
                    };
                });

                // Return in expected format
                return {
                    document: {
                        id: docData.document_id,
                        school: docData.school,
                        course: docData.course,
                        problem_type: docData.problem_type,
                        term: docData.term,
                        year: docData.year,
                        total_problems: docData.total_problems,
                        created_at: docData.created_at
                    },
                    problems: problems
                };

            } catch (error) {
                console.error('Error loading document from database:', error);
                throw error;
            }
        }

        async function loadProblemsByTopicForEditing() {
            if (!selectedTopic) {
                showError('No topic selected');
                return;
            }

            try {
                // Show loading state
                document.getElementById('loadDocumentBtn').innerHTML = '⏳ Loading...';
                document.getElementById('loadDocumentBtn').disabled = true;

                // Get all problems for this topic with their associated documents
                const { data: problems, error: problemsError } = await supabase
                    .from('problems')
                    .select(`
                        *,
                        documents:document_id(*)
                    `)
                    .eq('topic_id', selectedTopic)
                    .order('problem_id');

                if (problemsError) throw problemsError;

                if (!problems || problems.length === 0) {
                    showError('No problems found for the selected topic');
                    return;
                }

                // Get subproblems for all these problems
                const problemIds = problems.map(p => p.id);
                let subproblemsData = [];
                
                if (problemIds.length > 0) {
                    const { data: subs, error: subError } = await supabase
                        .from('subproblems')
                        .select('*')
                        .in('problem_id', problemIds);
                    
                    if (subError) throw subError;
                    subproblemsData = subs || [];
                }

                // Get topic name for display
                const { data: topicData, error: topicError } = await supabase
                    .from('topics')
                    .select('name')
                    .eq('id', selectedTopic)
                    .single();
                
                const topicName = topicData?.name || 'Unknown Topic';

                // Transform to JSON format
                const transformedProblems = problems.map(problem => {
                    // Get subproblems for this problem
                    const subprobs = subproblemsData.filter(sub => sub.problem_id === problem.id);
                    const subproblemsObj = {};
                    
                    subprobs.forEach(sub => {
                        subproblemsObj[sub.key] = {
                            problem_text: sub.problem_text,
                            correct_answer: sub.correct_answer,
                            hint: sub.hint,
                            solution: {
                                text: sub.solution_text,
                                images: []
                            },
                            images: [],
                            comment: sub.comment
                        };
                    });

                    return {
                        id: problem.problem_id,
                        doc_id: problem.documents?.document_id || 'unknown',
                        problem_text: problem.problem_text,
                        subproblems: subproblemsObj,
                        correct_answer: problem.correct_answer,
                        hint: problem.hint,
                        solution: {
                            text: problem.solution_text,
                            images: []
                        },
                        images: [],
                        difficulty: problem.difficulty,
                        topics: [selectedTopic],
                        math_approach: problem.math_approach,
                        reasoning_type: problem.reasoning_type,
                        comment: problem.comment,
                        importance: problem.importance,
                        updated_at: problem.updated_at,
                        version: problem.version
                    };
                });

                // Create a synthetic document for the topic
                const syntheticDocument = {
                    id: `topic_${selectedTopic}`,
                    school: 'Various',
                    course: 'Various', 
                    problem_type: `Topic: ${topicName}`,
                    term: '',
                    year: '',
                    total_problems: transformedProblems.length,
                    created_at: new Date().toISOString()
                };

                // Set up the data
                const documentData = {
                    document: syntheticDocument,
                    problems: transformedProblems
                };

                problemsData = documentData;
                originalData = JSON.parse(JSON.stringify(documentData));
                
                // Update UI
                displayProblemsList();
                updateStats();
                
                // Update file info
                document.getElementById('fileInfo').textContent = `Loaded: ${topicName} (${transformedProblems.length} problems)`;
                currentFileName = `topic_${selectedTopic}`;
                originalFileName = `topic_${selectedTopic}`;
                dataSourceType = 'database'; // Mark as database source
                
                // Save to localStorage
                localStorage.setItem('problemsData', JSON.stringify(problemsData));
                localStorage.setItem('currentFileName', currentFileName);
                localStorage.setItem('originalFileName', originalFileName);
                
                // Close modal
                closeReadDatabaseModal();
                
                showSuccess(`Loaded ${transformedProblems.length} problems for topic: ${topicName}`);
                
            } catch (error) {
                console.error('Error loading problems by topic:', error);
                showError('Error loading problems by topic: ' + error.message);
            } finally {
                // Restore button state
                document.getElementById('loadDocumentBtn').innerHTML = 'Load Problems';
                document.getElementById('loadDocumentBtn').disabled = false;
            }
        }

        // Close modal when clicking outside
        window.onclick = function(event) {
            const modal = document.getElementById('readDatabaseModal');
            if (event.target == modal) {
                closeReadDatabaseModal();
            }
        }

        // ===== CHANGE DETECTION SYSTEM =====
        function detectChangedProblems() {
            if (!originalData || !problemsData) {
                return [];
            }

            const changedProblems = [];
            
            problemsData.problems.forEach((currentProblem, index) => {
                const originalProblem = originalData.problems.find(p => p.id === currentProblem.id);
                
                if (!originalProblem) {
                    // This is a new problem (shouldn't happen in normal workflow, but handle it)
                    changedProblems.push({
                        index: index,
                        problemId: currentProblem.id,
                        reason: 'new problem'
                    });
                    return;
                }

                // Compare all relevant fields
                if (isProblemChanged(currentProblem, originalProblem)) {
                    changedProblems.push({
                        index: index,
                        problemId: currentProblem.id,
                        reason: 'modified'
                    });
                }
            });

            return changedProblems;
        }

        function isProblemChanged(current, original) {
            // Compare main problem fields
            const fieldsToCompare = [
                'problem_text', 'correct_answer', 'hint', 
                'difficulty', 'math_approach', 'reasoning_type', 'comment', 'importance'
            ];
            
            for (const field of fieldsToCompare) {
                if (current[field] !== original[field]) {
                    return true;
                }
            }

            // Compare solution text
            if (current.solution?.text !== original.solution?.text) {
                return true;
            }

            // Compare topics (convert to string for comparison since they're arrays)
            const currentTopics = JSON.stringify((current.topics || []).sort());
            const originalTopics = JSON.stringify((original.topics || []).sort());
            if (currentTopics !== originalTopics) {
                return true;
            }

            // Compare subproblems
            if (isSubproblemsChanged(current.subproblems, original.subproblems)) {
                return true;
            }

            return false;
        }

        function isSubproblemsChanged(currentSubprobs, originalSubprobs) {
            const currentKeys = Object.keys(currentSubprobs || {}).sort();
            const originalKeys = Object.keys(originalSubprobs || {}).sort();
            
            // Check if number of subproblems changed
            if (currentKeys.length !== originalKeys.length) {
                return true;
            }
            
            // Check if subproblem keys are different
            if (JSON.stringify(currentKeys) !== JSON.stringify(originalKeys)) {
                return true;
            }
            
            // Check each subproblem for changes
            for (const key of currentKeys) {
                const currentSub = currentSubprobs[key];
                const originalSub = originalSubprobs[key];
                
                if (!originalSub) {
                    return true; // New subproblem
                }
                
                // Compare subproblem fields
                const subFieldsToCompare = ['problem_text', 'correct_answer', 'hint', 'comment'];
                for (const field of subFieldsToCompare) {
                    if (currentSub[field] !== originalSub[field]) {
                        return true;
                    }
                }
                
                // Compare subproblem solution text
                if (currentSub.solution?.text !== originalSub.solution?.text) {
                    return true;
                }
            }
            
            return false;
        }

        function incrementVersion(currentVersion) {
            if (!currentVersion) {
                return 'v2';
            }
            
            // Extract version number (e.g., "v1" -> 1, "v10" -> 10)
            const match = currentVersion.match(/^v(\d+)$/);
            if (match) {
                const versionNumber = parseInt(match[1], 10);
                return `v${versionNumber + 1}`;
            }
            
            // If version format is unexpected, default to v2
            return 'v2';
        }

        function getChangesSummary() {
            const changedProblems = detectChangedProblems();
            
            if (changedProblems.length === 0) {
                return 'No changes detected.';
            }
            
            const problemIds = changedProblems.map(cp => cp.problemId).join(', ');
            return `${changedProblems.length} problem(s) changed: ${problemIds}`;
        }

        // ===== SOLUTION IMAGE UPLOAD FUNCTIONALITY =====
        function generateSolutionImagePreview(solution) {
            if (!solution || !solution.images || solution.images.length === 0) {
                return '<div style="color: #6c757d; font-size: 12px; font-style: italic;">No images uploaded</div>';
            }

            return solution.images.map((image, index) => `
                <div style="display: inline-block; margin: 5px; position: relative;">
                    <img src="${getSupabaseImageUrl(problemsData.document.id, image)}" 
                         alt="Solution Image ${index + 1}" 
                         style="max-width: 100px; max-height: 80px; border: 1px solid #dee2e6; border-radius: 4px;">
                    <button type="button" onclick="removeSolutionImage(${index})" 
                            style="position: absolute; top: -5px; right: -5px; background: #dc3545; color: white; border: none; border-radius: 50%; width: 20px; height: 20px; font-size: 12px; cursor: pointer;">×</button>
                    <div style="font-size: 10px; color: #6c757d; text-align: center; margin-top: 2px;">${image}</div>
                </div>
            `).join('');
        }

        async function handleSolutionImageUpload(event) {
            const files = event.target.files;
            if (!files || files.length === 0) return;

            if (currentProblemIndex < 0) {
                showError('No problem selected');
                return;
            }

            // Check admin password before uploading images
            if (!checkAdminPassword()) {
                event.target.value = ''; // Clear the file input
                return;
            }

            try {
                const problem = problemsData.problems[currentProblemIndex];
                const problemNumber = extractProblemNumber(problem.id);
                
                // Initialize solution.images array if needed
                if (!problem.solution) {
                    problem.solution = { text: null, images: [] };
                }
                if (!problem.solution.images) {
                    problem.solution.images = [];
                }

                // Calculate existing count once before loop
                const initialCount = problem.solution.images.length;
                
                for (let i = 0; i < files.length; i++) {
                    const file = files[i];
                    
                    // Generate automatic filename with sequential numbering
                    const filename = `p${problemNumber}_solution_${initialCount + i + 1}.${getFileExtension(file.name)}`;
                    
                    // Upload to Supabase Storage
                    const { error: uploadError } = await supabase.storage
                        .from(STORAGE_BUCKET)
                        .upload(`${problemsData.document.id}/images/${filename}`, file);

                    if (uploadError) {
                        console.error('Upload error:', uploadError);
                        showError(`Failed to upload ${file.name}: ${uploadError.message}`);
                        continue;
                    }

                    // Add to solution images array
                    problem.solution.images.push(filename);
                }

                // Update the preview
                const previewElement = document.getElementById('solutionImagePreview');
                if (previewElement) {
                    previewElement.innerHTML = generateSolutionImagePreview(problem.solution);
                }
                
                // Save changes
                localStorage.setItem('problemsData', JSON.stringify(problemsData));
                
                // Show detailed success message with filenames
                const uploadedNames = [];
                for (let i = 0; i < files.length; i++) {
                    const existingCount = problem.solution.images.length - files.length + i;
                    uploadedNames.push(`p${problemNumber}_solution_${existingCount + 1}.${getFileExtension(files[i].name)}`);
                }
                showSuccess(`${files.length} image(s) uploaded successfully: ${uploadedNames.join(', ')}`);
                
            } catch (error) {
                console.error('Error uploading images:', error);
                showError('Error uploading images: ' + error.message);
            }

            // Clear the input
            event.target.value = '';
        }

        async function removeSolutionImage(index) {
            if (currentProblemIndex < 0) return;

            const problem = problemsData.problems[currentProblemIndex];
            if (!problem.solution || !problem.solution.images || index >= problem.solution.images.length) {
                return;
            }

            // Get the image filename that will be removed
            const removedImageName = problem.solution.images[index];
            
            // Remove from array
            const removedImage = problem.solution.images.splice(index, 1)[0];
            
            // Delete from Supabase Storage
            try {
                const documentId = problemsData.document.id;
                const imagePath = `${documentId}/images/${removedImageName}`;
                
                const { error: deleteError } = await supabase.storage
                    .from(STORAGE_BUCKET)
                    .remove([imagePath]);

                if (deleteError) {
                    console.error('Error deleting image from storage:', deleteError);
                    showError(`Failed to delete image from storage: ${deleteError.message}`);
                    // Optionally re-add the image back to the array if storage deletion failed
                    // problem.solution.images.splice(index, 0, removedImage);
                    // return;
                }
            } catch (error) {
                console.error('Error deleting image from storage:', error);
                showError(`Failed to delete image from storage: ${error.message}`);
            }
            
            // Update preview
            const previewElement = document.getElementById('solutionImagePreview');
            if (previewElement) {
                previewElement.innerHTML = generateSolutionImagePreview(problem.solution);
            }
            
            // Save changes
            localStorage.setItem('problemsData', JSON.stringify(problemsData));
            
            showSuccess('Image removed from solution');
        }

        function extractProblemNumber(problemId) {
            // Extract problem number from ID like "upenn_math103_final_fall_2021_p1" -> "1"
            const match = problemId.match(/_p(\d+)$/);
            return match ? match[1] : '1';
        }

        function getFileExtension(filename) {
            return filename.slice((filename.lastIndexOf(".") - 1 >>> 0) + 2).toLowerCase();
        }

        function triggerSolutionImageUpload() {
            const fileInput = document.getElementById('solutionImageUpload');
            if (fileInput) {
                fileInput.click();
            }
        }

        // Debug function to test image URLs
        function testImageUrl(filename) {
            if (!problemsData || !problemsData.document) {
                console.log('No document loaded');
                return;
            }
            const documentId = problemsData.document.id;
            const imageUrl = getSupabaseImageUrl(documentId, filename);
            console.log(`Testing image URL: ${imageUrl}`);
            
            // Create a temporary image to test if it loads
            const testImg = new Image();
            testImg.onload = function() {
                console.log(`✅ Image loads successfully: ${filename}`);
                console.log(`Image dimensions: ${this.naturalWidth}x${this.naturalHeight}`);
            };
            testImg.onerror = function() {
                console.log(`❌ Failed to load image: ${filename}`);
                console.log(`URL attempted: ${imageUrl}`);
            };
            testImg.src = imageUrl;
        }

        // ===== PROBLEMS LIST DISPLAY FUNCTION =====
        function displayProblemsList() {
            if (!problemsData || !problemsData.problems) {
                return;
            }

            const problemList = document.getElementById('problemList');
            problemList.innerHTML = '';
            
            try {
                console.log(`Loading ${problemsData.problems.length} problems`);
                problemsData.problems.forEach((problem, index) => {
                    console.log(`Processing problem ${index + 1}: ${problem.id}`);
                    
                    // Initialize null fields to prevent errors
                    if (!problem.topics) problem.topics = [];
                    if (!problem.hint) problem.hint = null;
                    if (!problem.solution) problem.solution = { text: null, images: [] };
                    if (problem.solution && !problem.solution.text) problem.solution.text = null;
                    if (problem.solution && !problem.solution.images) problem.solution.images = [];
                    if (!problem.subproblems) problem.subproblems = {};
                    if (!problem.math_approach) problem.math_approach = null;
                    if (!problem.reasoning_type) problem.reasoning_type = null;
                    if (!problem.images) problem.images = [];
                    
                    // Convert topic names to IDs if needed
                    if (problem.topics && Array.isArray(problem.topics)) {
                        problem.topics = problem.topics.map(topic => {
                            if (typeof topic === 'string') {
                                // Find topic by name and convert to ID
                                const foundTopic = availableTopics.find(t => t.name === topic);
                                return foundTopic ? foundTopic.id : topic;
                            }
                            return topic;
                        });
                    }
                    
                    // Process subproblems
                    if (problem.subproblems && typeof problem.subproblems === 'object') {
                        Object.keys(problem.subproblems).forEach(key => {
                            const subproblem = problem.subproblems[key];
                            if (!subproblem.hint) subproblem.hint = null;
                            if (!subproblem.solution) subproblem.solution = { text: null, images: [] };
                            if (subproblem.solution && !subproblem.solution.text) subproblem.solution.text = null;
                            if (subproblem.solution && !subproblem.solution.images) subproblem.solution.images = [];
                            if (!subproblem.images) subproblem.images = [];
                        });
                    }

                    const problemItem = document.createElement('div');
                    problemItem.className = 'problem-item';
                    problemItem.onclick = () => selectProblem(index);
                    
                    const problemId = document.createElement('div');
                    problemId.className = 'problem-id';
                    problemId.textContent = problem.id;
                    
                    const problemStatus = document.createElement('div');
                    problemStatus.className = 'problem-status';
                    
                    problemItem.appendChild(problemId);
                    problemItem.appendChild(problemStatus);
                    problemList.appendChild(problemItem);
                });
                
                // Update all problem status indicators
                updateAllProblemStatuses();
                
                console.log('Problems list displayed successfully');
            } catch (error) {
                console.error('Error displaying problems list:', error);
                showError('Error displaying problems list: ' + error.message);
            }
        }

    </script>
</body>
</html> 