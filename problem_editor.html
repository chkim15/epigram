<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Math Problems Database Editor</title>
    <!-- MathJax for LaTeX rendering -->
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['\\(', '\\)']],
                displayMath: [['\\[', '\\]']],
                processEscapes: true,
                processEnvironments: true
            },
            options: {
                skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
            }
        };
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f5f5f5;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: white;
            color: #333;
            padding: 30px;
            text-align: center;
            border-bottom: 1px solid #e9ecef;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 0;
            font-weight: 300;
            color: #333;
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .controls {
            padding: 20px 30px;
            background: #f8f9fa;
            border-bottom: 1px solid #e9ecef;
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }

        .file-input {
            display: none;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.3s ease;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .btn-primary {
            background: #007bff;
            color: white;
        }

        .btn-primary:hover {
            background: #0056b3;
            transform: translateY(-2px);
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn-secondary:hover {
            background: #545b62;
            transform: translateY(-2px);
        }

        .btn-success {
            background: #28a745;
            color: white;
        }

        .btn-success:hover {
            background: #1e7e34;
            transform: translateY(-2px);
        }

        .btn-warning {
            background: #ffc107;
            color: #212529;
        }

        .btn-warning:hover {
            background: #e0a800;
            transform: translateY(-2px);
        }

        .main-content {
            display: flex;
            min-height: 600px;
        }

        .sidebar {
            width: 300px;
            background: #f8f9fa;
            border-right: 1px solid #e9ecef;
            overflow-y: auto;
            max-height: 600px;
        }

        .problem-list {
            list-style: none;
        }

        .problem-item {
            padding: 15px 20px;
            border-bottom: 1px solid #e9ecef;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .problem-item:hover {
            background: #e9ecef;
        }

        .problem-item.active {
            background: #007bff;
            color: white;
        }

        .problem-id {
            font-weight: 500;
            font-size: 14px;
        }

        .problem-status {
            font-size: 12px;
            padding: 4px 8px;
            border-radius: 12px;
            background: #28a745;
            color: white;
        }

        .problem-status.incomplete {
            background: #ffc107;
            color: #212529;
        }

        .problem-status.incomplete::before {
            content: "‚ö†";
            margin-right: 4px;
        }

        .problem-status.complete::before {
            content: "‚úì";
            margin-right: 4px;
        }

        .editor-panel {
            flex: 1;
            padding: 30px;
            overflow-y: auto;
            max-height: 600px;
        }

        .form-group {
            margin-bottom: 25px;
        }

        .form-label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #495057;
            font-size: 14px;
        }

        .form-control {
            width: 100%;
            padding: 12px 15px;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s ease;
            font-family: inherit;
        }

        .form-control:focus {
            outline: none;
            border-color: #007bff;
            box-shadow: 0 0 0 3px rgba(0,123,255,0.1);
        }

        textarea.form-control {
            min-height: 120px;
            resize: vertical;
        }

        .problem-text-display {
            background: #f8f9fa;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            min-height: 100px;
        }

        .problem-text-display:hover {
            border-color: #007bff;
            background: #f0f8ff;
        }

        .problem-text-display.editing {
            border-color: #007bff;
            background: white;
        }

        .problem-text-display .edit-hint {
            font-size: 12px;
            color: #6c757d;
            margin-top: 10px;
            font-style: italic;
        }

        .problem-text-display .edit-hint::before {
            content: "Click to edit LaTeX";
        }

        .problem-text-display.editing .edit-hint::before {
            content: "Editing LaTeX - click outside to save";
        }

        .answer-option-display .edit-hint {
            font-size: 12px;
            color: #6c757d;
            margin-top: 10px;
            font-style: italic;
        }

        .answer-option-display .edit-hint::before {
            content: "Click to edit LaTeX";
        }

        .answer-option-display.editing .edit-hint::before {
            content: "Editing LaTeX - click outside to save";
        }

        .problem-image {
            margin: 15px 0;
            text-align: center;
        }

        .problem-image img {
            max-width: 100%;
            max-height: 300px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }

        .problem-image .no-image {
            color: #6c757d;
            font-style: italic;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
            border: 2px dashed #dee2e6;
        }

        .answer-options {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 10px;
        }

        .answer-option {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            background: white;
        }

        .answer-option input[type="text"] {
            flex: 1;
            border: none;
            outline: none;
            font-size: 14px;
        }

        .answer-option textarea {
            flex: 1;
            border: none;
            outline: none;
            font-size: 14px;
            resize: vertical;
            min-height: 60px;
            font-family: inherit;
        }

        .answer-option.selected {
            border-color: #28a745;
            background: #f8fff9;
        }

        .answer-option-label {
            font-weight: bold;
            min-width: 30px;
            text-align: center;
        }

        .answer-option-display {
            background: #f8f9fa;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            min-height: 80px;
        }

        .answer-option-display:hover {
            border-color: #007bff;
            background: #f0f8ff;
        }

        .answer-option-display.editing {
            border-color: #007bff;
            background: white;
        }

        .answer-option-display .edit-hint {
            font-size: 12px;
            color: #6c757d;
            margin-top: 10px;
            font-style: italic;
        }

        .answer-option-display .edit-hint::before {
            content: "Click to edit LaTeX";
        }

        .answer-option-display.editing .edit-hint::before {
            content: "Editing LaTeX - click outside to save";
        }

        .text-answer-container {
            margin-top: 15px;
        }

        .text-answer-container .form-label {
            margin-bottom: 10px;
        }

        .text-answer-container textarea {
            min-height: 80px;
            font-family: 'Courier New', monospace;
        }

        .difficulty-buttons {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .difficulty-btn {
            padding: 8px 16px;
            border: 2px solid #e9ecef;
            background: white;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 14px;
        }

        .difficulty-btn:hover {
            border-color: #007bff;
        }

        .difficulty-btn.selected {
            background: #007bff;
            color: white;
            border-color: #007bff;
        }

        .topics-container {
            margin-top: 10px;
        }

        .topics-search-container {
            position: relative;
            margin-bottom: 15px;
        }

        .topics-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 2px solid #007bff;
            border-top: 1px solid #007bff;
            border-radius: 0 0 8px 8px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 9999;
            box-shadow: 0 8px 16px rgba(0,0,0,0.15);
        }

        .topics-dropdown-item {
            padding: 10px 15px;
            cursor: pointer;
            border-bottom: 1px solid #f8f9fa;
            transition: background-color 0.2s ease;
        }

        .topics-dropdown-item:hover {
            background-color: #f8f9fa;
        }

        .topics-dropdown-item:last-child {
            border-bottom: none;
        }

        .topics-dropdown-item.selected {
            background-color: #e3f2fd;
            color: #1976d2;
        }

        .topics-list {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .topic-tag {
            background: #e9ecef;
            color: #495057;
            padding: 6px 12px;
            border-radius: 15px;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .topic-tag:hover {
            background: #dc3545;
            color: white;
        }

        .topic-tag .remove {
            font-weight: bold;
            font-size: 14px;
        }

        .subproblems-container {
            margin: 15px 0;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            background: #f8f9fa;
        }

        .subproblems-header {
            padding: 15px;
            background: #e9ecef;
            border-bottom: 1px solid #dee2e6;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: 600;
        }

        .subproblems-header:hover {
            background: #dee2e6;
        }

        .subproblems-toggle {
            font-size: 16px;
            transition: transform 0.3s ease;
        }

        .subproblems-toggle.expanded {
            transform: rotate(90deg);
        }

        .subproblems-content {
            padding: 15px;
            display: none;
        }

        .subproblems-content.expanded {
            display: block;
        }

        .subproblem-item {
            margin-bottom: 15px;
            padding: 15px;
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 6px;
        }

        .subproblem-label {
            font-weight: bold;
            color: #495057;
            margin-bottom: 8px;
            font-size: 14px;
        }

        .domain-container {
            margin-top: 10px;
        }

        .domain-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 10px;
        }

        .domain-btn {
            padding: 6px 12px;
            border: 2px solid #e9ecef;
            background: white;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 12px;
        }

        .domain-btn:hover {
            border-color: #007bff;
        }

        .domain-btn.selected {
            background: #007bff;
            color: white;
            border-color: #007bff;
        }

        .approach-container {
            margin-top: 10px;
        }

        .approach-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 10px;
        }

        .reasoning-container {
            margin-top: 10px;
        }

        .reasoning-input {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .reasoning-input input {
            flex: 1;
        }

        .reasoning-list {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .subproblem-controls {
            margin-top: 10px;
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .subproblem-add-input {
            width: 60px;
            padding: 6px 10px;
            border: 2px solid #e9ecef;
            border-radius: 4px;
            text-align: center;
            font-size: 14px;
        }

        .subproblem-controls button {
            padding: 6px 12px;
            font-size: 12px;
        }

        .subproblem-remove {
            float: right;
            background: #dc3545;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 4px 8px;
            cursor: pointer;
            font-size: 12px;
            margin-top: 5px;
        }

        .subproblem-remove:hover {
            background: #c82333;
        }

        .save-section {
            margin-top: 30px;
            padding-top: 20px;
            border-top: 2px solid #e9ecef;
            text-align: center;
        }

        .problem-id-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .remove-problem-btn {
            background: #dc3545;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 6px 12px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
        }

        .remove-problem-btn:hover {
            background: #c82333;
        }

        .stats {
            display: flex;
            gap: 20px;
            margin-top: 20px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
        }

        .stat-item {
            text-align: center;
        }

        .stat-number {
            font-size: 2rem;
            font-weight: bold;
            color: #007bff;
        }

        .stat-label {
            font-size: 12px;
            color: #6c757d;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .no-problem {
            text-align: center;
            padding: 60px 20px;
            color: #6c757d;
        }

        .no-problem h3 {
            margin-bottom: 10px;
            color: #495057;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #6c757d;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #007bff;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .error {
            background: #f8d7da;
            color: #721c24;
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
            border: 1px solid #f5c6cb;
        }

        .success {
            background: #d4edda;
            color: #155724;
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
            border: 1px solid #c3e6cb;
        }

        @media (max-width: 768px) {
            .main-content {
                flex-direction: column;
            }
            
            .sidebar {
                width: 100%;
                max-height: 200px;
            }
            
            .controls {
                flex-direction: column;
                align-items: stretch;
            }
            
            .answer-options {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Math Problems Database Editor</h1>
        </div>

        <div class="controls">
            <input type="file" id="fileInput" class="file-input" accept=".json">
            <button class="btn btn-primary" onclick="document.getElementById('fileInput').click()">
                üìÅ Load JSON File
            </button>
            <button class="btn btn-success" onclick="exportData()">
                üíæ Export JSON
            </button>
            <div id="fileInfo" style="margin-left: auto; color: #6c757d; font-size: 14px;"></div>
        </div>

        <div class="main-content">
            <div class="sidebar">
                <div id="problemList" class="problem-list">
                    <div class="no-problem" style="padding: 40px 20px; text-align: center; color: #6c757d;">
                        <h3 style="margin-bottom: 10px; color: #495057;">No File Loaded</h3>
                        <p>Load a JSON file to start editing</p>
                    </div>
                </div>
            </div>

            <div class="editor-panel">
                <div id="noProblem" class="no-problem">
                    <h3>No Problem Selected</h3>
                    <p>Select a problem from the sidebar to start editing</p>
                </div>
            </div>
        </div>

        <div class="stats" id="stats" style="display: none;">
            <div class="stat-item">
                <div class="stat-number" id="totalProblems">0</div>
                <div class="stat-label">Total Problems</div>
            </div>
            <div class="stat-item">
                <div class="stat-number" id="completedProblems">0</div>
                <div class="stat-label">Completed</div>
            </div>
            <div class="stat-item">
                <div class="stat-number" id="incompleteProblems">0</div>
                <div class="stat-label">Incomplete</div>
            </div>
        </div>
    </div>

    <script>
        let problemsData = null;
        let currentProblemIndex = -1;
        let originalData = null;
        let imageBasePath = '';
        let currentFileName = '';
        let originalFileName = '';
        let availableTopics = [];

        // Load topics data - embedded to avoid fetch issues
        function loadTopics() {
            availableTopics = [
                {"id": 1, "name": "Variables, Functions and Graphs"},
                {"id": 2, "name": "Limits of Functions"},
                {"id": 3, "name": "Intermediate Form Limits"},
                {"id": 4, "name": "Continuity"},
                {"id": 5, "name": "Limits at Infinity and Asymptotes"},
                {"id": 6, "name": "Derivatives"},
                {"id": 7, "name": "Differentiation Rules (Chain, Product and Quotient Rules)"},
                {"id": 8, "name": "Implicit Differentiation and Inverse Derivatives"},
                {"id": 9, "name": "Approximation via Differentiation"},
                {"id": 10, "name": "Logarithmic Differentiation"},
                {"id": 11, "name": "Inverse Trigonometric Functions"},
                {"id": 12, "name": "Hyperbolic Functions"},
                {"id": 13, "name": "Indeterminate Forms and L'Hospital Rule"},
                {"id": 14, "name": "Order of Growth"},
                {"id": 15, "name": "Mean Value Theorem"},
                {"id": 16, "name": "Monotonicity and Concavity"},
                {"id": 17, "name": "Applied Optimization"},
                {"id": 18, "name": "Antiderivatives"},
                {"id": 19, "name": "Riemann Sum and Definite Integral"},
                {"id": 20, "name": "Fundamental Theorem of Calculus"},
                {"id": 21, "name": "Substitution Rules"},
                {"id": 22, "name": "Area Between Curves"},
                {"id": 23, "name": "Volume by Slicing"},
                {"id": 24, "name": "Volume by Cylindrical Shells"},
                {"id": 25, "name": "Integration by Parts"},
                {"id": 26, "name": "Partial Fractions"},
                {"id": 27, "name": "Improper Integrals"},
                {"id": 28, "name": "Arc Length"},
                {"id": 29, "name": "Surface Area"},
                {"id": 30, "name": "Sequences"},
                {"id": 31, "name": "Series"},
                {"id": 32, "name": "Integral Tests"},
                {"id": 33, "name": "Comparison Tests"},
                {"id": 34, "name": "Alternating Series"},
                {"id": 35, "name": "Absolute Convergence, Ratio and Root Test"},
                {"id": 36, "name": "Power Series"},
                {"id": 37, "name": "Taylor and MacLaurin Series"},
                {"id": 38, "name": "Applications of Taylor Polynomials"},
                {"id": 39, "name": "Separable and Homogeneous ODE"},
                {"id": 40, "name": "First Order Linear ODE"},
                {"id": 41, "name": "Second Order Linear ODE"},
                {"id": 42, "name": "Nonhomogeneous Linear ODE"},
                {"id": 43, "name": "Series Solutions of ODE"}
            ];
            console.log('Topics loaded:', availableTopics.length);
        }

        // File input handling
        document.getElementById('fileInput').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        problemsData = JSON.parse(e.target.result);
                        originalData = JSON.parse(e.target.result);
                        loadProblems();
                        currentFileName = file.name.replace('.json', '');
                        originalFileName = file.name;
                        document.getElementById('fileInfo').textContent = `Loaded: ${file.name}`;
                    } catch (error) {
                        showError('Invalid JSON file. Please check the file format.');
                    }
                };
                reader.readAsText(file);
            }
        });

        function loadProblems() {
            if (!problemsData || !problemsData.problems) {
                showError('Invalid data format. Expected a JSON object with a "problems" array.');
                return;
            }

            const problemList = document.getElementById('problemList');
            problemList.innerHTML = '';

            problemsData.problems.forEach((problem, index) => {
                // Set calculus as default domain if no domain is set
                if (!problem.domain || problem.domain.length === 0) {
                    problem.domain = ['calculus'];
                }
                
                // Convert topic names to IDs if needed
                if (problem.topics && Array.isArray(problem.topics)) {
                    problem.topics = problem.topics.map(topic => {
                        if (typeof topic === 'string') {
                            // Find topic by name and convert to ID
                            const foundTopic = availableTopics.find(t => t.name === topic);
                            return foundTopic ? foundTopic.id : topic;
                        }
                        return topic; // Already an ID
                    });
                }
                
                const isComplete = problem.manually_saved && isProblemComplete(problem);
                const listItem = document.createElement('div');
                listItem.className = 'problem-item';
                listItem.onclick = () => selectProblem(index);
                
                listItem.innerHTML = `
                    <div class="problem-id">${problem.id}</div>
                    <div class="problem-status ${isComplete ? 'complete' : 'incomplete'}">
                    </div>
                `;
                
                problemList.appendChild(listItem);
            });

            updateStats();
            selectProblem(0);
        }

        function selectProblem(index) {
            if (index < 0 || index >= problemsData.problems.length) return;

            // Remove active class from all items
            document.querySelectorAll('.problem-item').forEach(item => {
                item.classList.remove('active');
            });

            // Add active class to selected item
            document.querySelectorAll('.problem-item')[index].classList.add('active');

            currentProblemIndex = index;
            const problem = problemsData.problems[index];
            displayProblem(problem);
            
            // Scroll to top of editor panel
            const editorPanel = document.querySelector('.editor-panel');
            if (editorPanel) {
                editorPanel.scrollTop = 0;
            }
        }

        function displayProblem(problem) {
            const editorPanel = document.querySelector('.editor-panel');
            const isTextAnswer = !problem.answer_options;
            
            editorPanel.innerHTML = `
                <div class="form-group">
                    <label class="form-label">Problem ID</label>
                    <div class="problem-id-container">
                        <input type="text" class="form-control" value="${problem.id}" readonly style="flex: 1;">
                        <button class="remove-problem-btn" onclick="removeProblem()">Remove Problem</button>
                    </div>
                </div>

                <div class="form-group">
                    <label class="form-label">Problem Text</label>
                    <div class="problem-text-display" onclick="toggleProblemTextEdit()" id="problemTextDisplay">
                        <div id="problemTextRendered">${problem.problem_text || ''}</div>
                    </div>
                    <div class="answer-option" id="problemTextEdit" style="display: none;">
                        <textarea onchange="updateProblem('problem_text', this.value)" onblur="saveProblemText()" onkeydown="handleMultilineEdit(event)" placeholder="Enter problem text...">${problem.problem_text || ''}</textarea>
                    </div>
                </div>

                ${problem.images && problem.images.length > 0 ? `
                <div class="form-group">
                    <label class="form-label">Images</label>
                    <div class="problem-image" id="problemImage">
                        ${generateProblemImage(problem.images)}
                    </div>
                </div>
                ` : ''}

                ${generateSubproblemsSection(problem.subproblems)}

                ${isTextAnswer ? `
                    <div class="form-group">
                        <label class="form-label">Correct Answer</label>
                        <div class="problem-text-display" onclick="toggleTextAnswerEdit()" id="textAnswerDisplay">
                            <div id="textAnswerRendered">${problem.correct_answer || ''}</div>
                        </div>
                        <div class="answer-option" id="textAnswerEdit" style="display: none;">
                            <textarea onchange="updateProblem('correct_answer', this.value)" onblur="saveTextAnswer()" onkeydown="handleMultilineEdit(event)" placeholder="Enter the answer...">${problem.correct_answer || ''}</textarea>
                        </div>
                    </div>
                ` : `
                    <div class="form-group">
                        <label class="form-label">Answer Options</label>
                        <div class="answer-options" id="answerOptions">
                            ${generateAnswerOptions(problem.answer_options)}
                        </div>
                    </div>

                    <div class="form-group">
                        <label class="form-label">Correct Answer</label>
                        <select class="form-control" id="correctAnswer" onchange="updateProblem('correct_answer', this.value)">
                            <option value="">Select correct answer...</option>
                            ${generateCorrectAnswerOptions(problem.answer_options)}
                        </select>
                    </div>
                `}

                <div class="form-group">
                    <label class="form-label">Solution</label>
                    <div class="problem-text-display" onclick="toggleSolutionEdit()" id="solutionDisplay">
                        <div id="solutionRendered">${problem.solution || ''}</div>
                    </div>
                    <div class="answer-option" id="solutionEdit" style="display: none;">
                        <textarea onchange="updateProblem('solution', this.value)" onblur="saveSolution()" onkeydown="handleMultilineEdit(event)" placeholder="Enter solution...">${problem.solution || ''}</textarea>
                    </div>
                </div>

                <div class="form-group">
                    <label class="form-label">Difficulty Level</label>
                    <div class="difficulty-buttons">
                        <button class="difficulty-btn ${problem.difficulty === 'easy' ? 'selected' : ''}" onclick="setDifficulty('easy')">Easy</button>
                        <button class="difficulty-btn ${problem.difficulty === 'medium' ? 'selected' : ''}" onclick="setDifficulty('medium')">Medium</button>
                        <button class="difficulty-btn ${problem.difficulty === 'hard' ? 'selected' : ''}" onclick="setDifficulty('hard')">Hard</button>
                        <button class="difficulty-btn ${problem.difficulty === 'very_hard' ? 'selected' : ''}" onclick="setDifficulty('very_hard')">Very Hard</button>
                    </div>
                </div>

                <div class="form-group">
                    <label class="form-label">Domain</label>
                    <div class="domain-container">
                        <div class="domain-buttons" id="domainButtons">
                            ${generateDomainButtons(problem.domain || [])}
                        </div>
                    </div>
                </div>

                <div class="form-group">
                    <label class="form-label">Topics</label>
                    <div class="topics-container">
                        <div class="topics-search-container" style="position: relative;">
                            <input type="text" class="form-control" id="topicSearchInput" placeholder="Search topics..." oninput="handleTopicInput()" onfocus="showTopicsDropdown()" onblur="hideTopicsDropdown()">
                            <button type="button" style="position: absolute; right: 5px; top: 5px; background: #007bff; color: white; border: none; border-radius: 4px; padding: 5px 10px; cursor: pointer; z-index: 10;" onclick="testTopicsDropdown()">‚ñº</button>
                            <div id="topicsDropdown" class="topics-dropdown" style="display: none;">
                                <!-- Topics will be populated here -->
                            </div>
                        </div>
                        <div class="topics-list" id="topicsList">
                            ${generateTopicsList(problem.topics || [])}
                        </div>
                    </div>
                </div>

                <div class="form-group">
                    <label class="form-label">Mathematical Approach</label>
                    <div class="approach-container">
                        <div class="approach-buttons" id="approachButtons">
                            ${generateApproachButtons(problem.math_approach || [])}
                        </div>
                    </div>
                </div>

                <div class="form-group">
                    <label class="form-label">Type of Reasoning</label>
                    <div class="reasoning-buttons">
                        ${generateReasoningButtons(problem.reasoning_type || [])}
                    </div>
                </div>

                <div class="save-section">
                    <button class="btn btn-success" onclick="saveCurrentProblem()">
                        üíæ Save Problem
                    </button>
                </div>
            `;

            // Set correct answer if it exists
            if (problem.correct_answer && !isTextAnswer) {
                document.getElementById('correctAnswer').value = problem.correct_answer;
            }

            // Render LaTeX for problem text, answer options, solution, text answer, and subproblems
            if (window.MathJax) {
                const elementsToRender = [
                    document.getElementById('problemTextRendered'),
                    document.getElementById('solutionRendered')
                ];
                
                // Add text answer element if it exists
                if (isTextAnswer) {
                    elementsToRender.push(document.getElementById('textAnswerRendered'));
                }
                
                // Add answer option elements to rendering queue
                if (!isTextAnswer && problem.answer_options) {
                    Object.keys(problem.answer_options).forEach(key => {
                        const answerElement = document.getElementById(`answerOptionRendered_${key}`);
                        if (answerElement) {
                            elementsToRender.push(answerElement);
                        }
                    });
                }
                
                // Add subproblem elements to rendering queue
                if (problem.subproblems) {
                    Object.keys(problem.subproblems).forEach(key => {
                        const subproblemElement = document.getElementById(`subproblemRendered_${key}`);
                        const subproblemAnswerElement = document.getElementById(`subproblemAnswerRendered_${key}`);
                        const subproblemSolutionElement = document.getElementById(`subproblemSolutionRendered_${key}`);
                        if (subproblemElement) {
                            elementsToRender.push(subproblemElement);
                        }
                        if (subproblemAnswerElement) {
                            elementsToRender.push(subproblemAnswerElement);
                        }
                        if (subproblemSolutionElement) {
                            elementsToRender.push(subproblemSolutionElement);
                        }
                    });
                }
                
                // Auto-resize all textareas after rendering
                setTimeout(() => {
                    document.querySelectorAll('textarea').forEach(textarea => {
                        autoResizeTextarea(textarea);
                    });
                }, 100);
                
                MathJax.typesetPromise(elementsToRender);
            }
        }

        function toggleProblemTextEdit() {
            const display = document.getElementById('problemTextDisplay');
            const rendered = document.getElementById('problemTextRendered');
            const edit = document.getElementById('problemTextEdit');
            
            if (display.style.display === 'none') {
                // Save and switch to display mode
                const newText = edit.querySelector('textarea').value;
                rendered.innerHTML = newText;
                display.style.display = 'block';
                edit.style.display = 'none';
                updateProblem('problem_text', newText);
                
                // Re-render LaTeX
                if (window.MathJax) {
                    MathJax.typesetPromise([rendered]);
                }
            } else {
                // Switch to edit mode
                display.style.display = 'none';
                edit.style.display = 'flex';
                const textarea = edit.querySelector('textarea');
                textarea.focus();
                autoResizeTextarea(textarea);
            }
        }

        function saveProblemText() {
            toggleProblemTextEdit();
        }

        function toggleTextAnswerEdit() {
            const display = document.getElementById('textAnswerDisplay');
            const rendered = document.getElementById('textAnswerRendered');
            const edit = document.getElementById('textAnswerEdit');
            
            if (display.style.display === 'none') {
                // Save and switch to display mode
                const newText = edit.querySelector('textarea').value;
                rendered.innerHTML = newText;
                display.style.display = 'block';
                edit.style.display = 'none';
                updateProblem('correct_answer', newText);
                
                // Re-render LaTeX
                if (window.MathJax) {
                    MathJax.typesetPromise([rendered]);
                }
            } else {
                // Switch to edit mode
                display.style.display = 'none';
                edit.style.display = 'flex';
                const textarea = edit.querySelector('textarea');
                textarea.focus();
                autoResizeTextarea(textarea);
            }
        }

        function saveTextAnswer() {
            toggleTextAnswerEdit();
        }

        function toggleSolutionEdit() {
            const display = document.getElementById('solutionDisplay');
            const rendered = document.getElementById('solutionRendered');
            const edit = document.getElementById('solutionEdit');
            
            if (display.style.display === 'none') {
                // Save and switch to display mode
                const newText = edit.querySelector('textarea').value;
                rendered.innerHTML = newText;
                display.style.display = 'block';
                edit.style.display = 'none';
                updateProblem('solution', newText);
                
                // Re-render LaTeX
                if (window.MathJax) {
                    MathJax.typesetPromise([rendered]);
                }
            } else {
                // Switch to edit mode
                display.style.display = 'none';
                edit.style.display = 'flex';
                const textarea = edit.querySelector('textarea');
                textarea.focus();
                autoResizeTextarea(textarea);
            }
        }

        function saveSolution() {
            toggleSolutionEdit();
        }

        function generateProblemImage(images) {
            return generateImageSection(images);
        }

        function generateImageSection(images) {
            const hasImages = images && images.length > 0;
            
            if (!hasImages) {
                return '';
            }
            
            const imageCount = images.length;
            
            const imageContent = images.map((image, index) => {
                // Detect if running on GitHub Pages and use appropriate path
                const isGitHubPages = window.location.hostname.includes('github.io');
                const basePath = isGitHubPages ? '/math-problem-converter' : '';
                const imagePath = `${basePath}/output/${currentFileName}/images/${image}`;
                return `
                    <div class="image-item" style="margin-bottom: 15px; position: relative; display: inline-block;">
                        <img src="${imagePath}" alt="Problem image" style="max-width: 100%; max-height: 200px; border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.1);" onerror="this.style.display='none'; this.nextElementSibling.style.display='block';">
                        <div class="no-image" style="display: none; color: #6c757d; font-style: italic; padding: 20px; background: #f8f9fa; border-radius: 8px; border: 2px dashed #dee2e6;">Image not found: ${image}</div>
                        <div style="text-align: center; margin-top: 8px; font-size: 12px; color: #6c757d;">${image}</div>
                    </div>
                `;
            }).join('');
            
            return `
                <div class="images-header" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; padding: 10px; background: #e9ecef; border-radius: 6px;">
                    <span style="font-weight: 600; color: #495057;">Images (${imageCount})</span>
                </div>
                <div class="images-content">
                    ${imageContent}
                </div>
            `;
        }

        function generateSubproblemImageSection(images) {
            const hasImages = images && images.length > 0;
            
            if (!hasImages) {
                return '';
            }
            
            return images.map((image, index) => {
                // Detect if running on GitHub Pages and use appropriate path
                const isGitHubPages = window.location.hostname.includes('github.io');
                const basePath = isGitHubPages ? '/math-problem-converter' : '';
                const imagePath = `${basePath}/output/${currentFileName}/images/${image}`;
                return `
                    <div class="image-item" style="margin-bottom: 15px; position: relative; display: inline-block;">
                        <img src="${imagePath}" alt="Subproblem image" style="max-width: 100%; max-height: 200px; border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.1);" onerror="this.style.display='none'; this.nextElementSibling.style.display='block';">
                        <div class="no-image" style="display: none; color: #6c757d; font-style: italic; padding: 20px; background: #f8f9fa; border-radius: 8px; border: 2px dashed #dee2e6;">Image not found: ${image}</div>
                        <div style="text-align: center; margin-top: 8px; font-size: 12px; color: #6c757d;">${image}</div>
                    </div>
                `;
            }).join('');
        }

        function generateAnswerOptions(answerOptions) {
            if (!answerOptions) {
                return '<p style="color: #6c757d; font-style: italic;">No answer options available</p>';
            }

            return Object.entries(answerOptions).map(([key, value]) => `
                <div class="answer-option-display" onclick="toggleAnswerOptionEdit('${key}')" id="answerOptionDisplay_${key}">
                    <div class="answer-option-label">${key}:</div>
                    <div id="answerOptionRendered_${key}">${value}</div>
                </div>
                <div class="answer-option" id="answerOptionEdit_${key}" style="display: none;">
                    <div class="answer-option-label">${key}:</div>
                    <textarea onchange="updateAnswerOption('${key}', this.value)" onblur="saveAnswerOption('${key}')" onkeydown="handleMultilineEdit(event)" placeholder="Enter answer option...">${value}</textarea>
                </div>
            `).join('');
        }

        function toggleAnswerOptionEdit(key) {
            const display = document.getElementById(`answerOptionDisplay_${key}`);
            const edit = document.getElementById(`answerOptionEdit_${key}`);
            
            if (display.style.display === 'none') {
                // Save and switch to display mode
                const newValue = edit.querySelector('textarea').value;
                const rendered = document.getElementById(`answerOptionRendered_${key}`);
                rendered.innerHTML = newValue;
                display.style.display = 'block';
                edit.style.display = 'none';
                updateAnswerOption(key, newValue);
                
                // Re-render LaTeX
                if (window.MathJax) {
                    MathJax.typesetPromise([rendered]);
                }
            } else {
                // Switch to edit mode
                display.classList.add('editing');
                display.style.display = 'none';
                edit.style.display = 'flex';
                const textarea = edit.querySelector('textarea');
                textarea.focus();
                autoResizeTextarea(textarea);
            }
        }

        function saveAnswerOption(key) {
            toggleAnswerOptionEdit(key);
        }

        function generateCorrectAnswerOptions(answerOptions) {
            if (!answerOptions) return '';
            
            return Object.keys(answerOptions).map(key => 
                `<option value="${key}">${key}</option>`
            ).join('');
        }

        function generateTopicsList(topicIds) {
            if (!topicIds || topicIds.length === 0) {
                return '<p style="color: #6c757d; font-style: italic;">No topics added</p>';
            }

            return topicIds.map(topicId => {
                const topic = availableTopics.find(t => t.id === topicId);
                const displayName = topic ? topic.name : `Topic ${topicId}`;
                return `
                    <div class="topic-tag" onclick="removeTopic(${topicId})">
                        ${displayName}
                        <span class="remove">√ó</span>
                    </div>
                `;
            }).join('');
        }

        function generateSubproblemsSection(subproblems) {
            const hasSubproblems = subproblems && Object.keys(subproblems).length > 0;
            
            const subproblemItems = hasSubproblems ? Object.entries(subproblems).sort().map(([key, subproblemData]) => {
                // Handle both old format (string) and new format (object)
                const problemText = typeof subproblemData === 'string' ? subproblemData : (subproblemData.problem_text || '');
                const correctAnswer = typeof subproblemData === 'object' ? (subproblemData.correct_answer || '') : '';
                const solution = typeof subproblemData === 'object' ? (subproblemData.solution || '') : '';
                const images = typeof subproblemData === 'object' ? (subproblemData.images || []) : [];
                
                return `
                <div class="subproblem-item" id="subproblemItem_${key}">
                    <div class="subproblem-label">${key}:
                        <button class="subproblem-remove" onclick="removeSubproblem('${key}')">Remove</button>
                    </div>
                    <div class="problem-text-display" onclick="toggleSubproblemEdit('${key}')" id="subproblemDisplay_${key}">
                        <div id="subproblemRendered_${key}">${problemText}</div>
                    </div>
                    <div class="answer-option" id="subproblemEdit_${key}" style="display: none;">
                        <textarea onchange="updateSubproblemText('${key}', this.value)" onblur="saveSubproblem('${key}')" onkeydown="handleMultilineEdit(event)" placeholder="Enter subproblem text...">${problemText}</textarea>
                    </div>
                    ${images.length > 0 ? `
                    <div class="form-group" style="margin-top: 10px;">
                        <label class="form-label" style="font-size: 12px;">Images (${key})</label>
                        <div class="problem-image">
                            ${generateSubproblemImageSection(images)}
                        </div>
                    </div>
                    ` : ''}
                    <div class="form-group" style="margin-top: 10px;">
                        <label class="form-label" style="font-size: 12px;">Correct Answer (${key})</label>
                        <div class="problem-text-display" onclick="toggleSubproblemAnswerEdit('${key}')" id="subproblemAnswerDisplay_${key}">
                            <div id="subproblemAnswerRendered_${key}">${correctAnswer}</div>
                        </div>
                        <div class="answer-option" id="subproblemAnswerEdit_${key}" style="display: none;">
                            <textarea onchange="updateSubproblemAnswer('${key}', this.value)" onblur="saveSubproblemAnswer('${key}')" onkeydown="handleMultilineEdit(event)" placeholder="Enter correct answer...">${correctAnswer}</textarea>
                        </div>
                    </div>
                    <div class="form-group" style="margin-top: 10px;">
                        <label class="form-label" style="font-size: 12px;">Solution (${key})</label>
                        <div class="problem-text-display" onclick="toggleSubproblemSolutionEdit('${key}')" id="subproblemSolutionDisplay_${key}">
                            <div id="subproblemSolutionRendered_${key}">${solution}</div>
                        </div>
                        <div class="answer-option" id="subproblemSolutionEdit_${key}" style="display: none;">
                            <textarea onchange="updateSubproblemSolution('${key}', this.value)" onblur="saveSubproblemSolution('${key}')" onkeydown="handleMultilineEdit(event)" placeholder="Enter solution..." style="min-height: 60px;">${solution}</textarea>
                        </div>
                    </div>
                </div>
                `;
            }).join('') : '';

            const expandedClass = hasSubproblems ? 'expanded' : '';
            const toggleSymbol = hasSubproblems ? '‚ñº' : '‚ñ∂';
            const count = hasSubproblems ? Object.keys(subproblems).length : 0;

            return `
                <div class="subproblems-container">
                    <div class="subproblems-header" onclick="toggleSubproblems()">
                        <span>Sub-Problems (${count})</span>
                        <span class="subproblems-toggle ${expandedClass}" id="subproblemsToggle">${toggleSymbol}</span>
                    </div>
                    <div class="subproblems-content ${expandedClass}" id="subproblemsContent">
                        ${subproblemItems}
                        <div class="subproblem-controls">
                            <input type="text" class="subproblem-add-input" id="newSubproblemKey" placeholder="a" maxlength="1">
                            <button class="btn btn-primary" onclick="addSubproblem()">Add Subproblem</button>
                        </div>
                    </div>
                </div>
            `;
        }

        function generateDomainButtons(domains) {
            const availableDomains = ['Calculus'];
            
            return availableDomains.map(domain => `
                <button class="domain-btn ${domains.includes(domain.toLowerCase()) ? 'selected' : ''}" onclick="toggleDomain('${domain}')">
                    ${domain}
                </button>
            `).join('');
        }

        function generateApproachButtons(approaches) {
            const availableApproaches = ['Algebraic', 'Geometric', 'Combinatorial', 'Approximation', 'Intuitive', 'Algorithmic', 'Logical', 'Symmetric', 'Statistical', 'Nontraditional'];
            
            return availableApproaches.map(approach => `
                <button class="domain-btn ${approaches.includes(approach.toLowerCase()) ? 'selected' : ''}" onclick="toggleApproach('${approach}')">
                    ${approach}
                </button>
            `).join('');
        }

        function generateReasoningButtons(reasonings) {
            const availableReasonings = ['Proof-based', 'Example Construction', 'Counterexample Construction', 'Computational', 'Conceptual', 'Application-based'];
            
            return availableReasonings.map(reasoning => `
                <button class="domain-btn ${reasonings.includes(reasoning.toLowerCase()) ? 'selected' : ''}" onclick="toggleReasoning('${reasoning}')">
                    ${reasoning}
                </button>
            `).join('');
        }

        function updateProblem(field, value) {
            if (currentProblemIndex >= 0) {
                problemsData.problems[currentProblemIndex][field] = value;
                // Don't auto-update completion status here
            }
        }

        function updateAnswerOption(key, value) {
            if (currentProblemIndex >= 0) {
                if (!problemsData.problems[currentProblemIndex].answer_options) {
                    problemsData.problems[currentProblemIndex].answer_options = {};
                }
                problemsData.problems[currentProblemIndex].answer_options[key] = value;
                // Don't auto-update completion status here
            }
        }

        function setDifficulty(difficulty) {
            if (currentProblemIndex >= 0) {
                problemsData.problems[currentProblemIndex].difficulty = difficulty;
            }
            
            // Update UI
            document.querySelectorAll('.difficulty-btn').forEach(btn => {
                btn.classList.remove('selected');
            });
            event.target.classList.add('selected');
        }

        function filterTopics() {
            console.log('filterTopics called');
            const searchInput = document.getElementById('topicSearchInput');
            const dropdown = document.getElementById('topicsDropdown');
            
            if (!searchInput) {
                console.log('searchInput not found');
                return;
            }
            
            if (!dropdown) {
                console.log('dropdown not found');
                return;
            }
            
            const searchTerm = searchInput.value.toLowerCase();
            console.log('Search term:', searchTerm);
            console.log('Available topics:', availableTopics.length);
            
            // Get current topic IDs, default to empty array if no problem selected
            const currentTopicIds = (currentProblemIndex >= 0 && problemsData && problemsData.problems) 
                ? (problemsData.problems[currentProblemIndex].topics || [])
                : [];
            
            console.log('Current topic IDs:', currentTopicIds);
            
            let filteredTopics;
            if (!searchTerm) {
                // Show all topics if no search term
                filteredTopics = availableTopics.filter(topic => !currentTopicIds.includes(topic.id));
            } else {
                // Filter by search term
                filteredTopics = availableTopics.filter(topic => 
                    topic.name.toLowerCase().includes(searchTerm) && 
                    !currentTopicIds.includes(topic.id)
                );
            }
            
            console.log('Filtered topics:', filteredTopics.length);
            
            dropdown.innerHTML = filteredTopics.map(topic => `
                <div class="topics-dropdown-item" onmousedown="addTopicById(${topic.id})">
                    ${topic.name}
                </div>
            `).join('');
            
            if (filteredTopics.length === 0 && searchTerm) {
                dropdown.innerHTML = '<div class="topics-dropdown-item" style="color: #6c757d; font-style: italic;">No topics found</div>';
            }
        }

        function showTopicsDropdown() {
            console.log('showTopicsDropdown called');
            const dropdown = document.getElementById('topicsDropdown');
            if (!dropdown) {
                console.log('dropdown element not found');
                return;
            }
            dropdown.style.display = 'block';
            console.log('dropdown display set to block');
            filterTopics(); // Show filtered results
        }

        function handleTopicInput() {
            console.log('handleTopicInput called');
            showTopicsDropdown();
            filterTopics();
        }

        function testTopicsDropdown() {
            console.log('Test button clicked');
            console.log('Available topics:', availableTopics.length);
            const dropdown = document.getElementById('topicsDropdown');
            if (dropdown) {
                dropdown.style.display = dropdown.style.display === 'none' ? 'block' : 'none';
                if (dropdown.style.display === 'block') {
                    filterTopics();
                }
            }
        }

        function hideTopicsDropdown() {
            setTimeout(() => {
                const dropdown = document.getElementById('topicsDropdown');
                if (dropdown) {
                    dropdown.style.display = 'none';
                }
                const searchInput = document.getElementById('topicSearchInput');
                if (searchInput) {
                    searchInput.value = '';
                }
            }, 300); // Longer delay to allow click events to fire
        }

        function addTopicById(topicId) {
            console.log('addTopicById called with ID:', topicId);
            
            if (currentProblemIndex >= 0 && problemsData && problemsData.problems) {
                if (!problemsData.problems[currentProblemIndex].topics) {
                    problemsData.problems[currentProblemIndex].topics = [];
                }
                
                if (!problemsData.problems[currentProblemIndex].topics.includes(topicId)) {
                    problemsData.problems[currentProblemIndex].topics.push(topicId);
                    console.log('Topic added:', topicId);
                    updateTopicsList();
                    
                    // Clear search and hide dropdown
                    const searchInput = document.getElementById('topicSearchInput');
                    const dropdown = document.getElementById('topicsDropdown');
                    if (searchInput) searchInput.value = '';
                    if (dropdown) dropdown.style.display = 'none';
                } else {
                    console.log('Topic already exists');
                }
            } else {
                console.log('No problem selected or problemsData not available');
                alert('Please load a JSON file and select a problem first');
            }
        }

        function removeTopic(topicId) {
            if (currentProblemIndex >= 0) {
                const topics = problemsData.problems[currentProblemIndex].topics;
                const index = topics.indexOf(topicId);
                if (index > -1) {
                    topics.splice(index, 1);
                    updateTopicsList();
                }
            }
        }

        function updateTopicsList() {
            const topicsList = document.getElementById('topicsList');
            const topics = problemsData.problems[currentProblemIndex].topics || [];
            topicsList.innerHTML = generateTopicsList(topics);
        }

        function toggleSubproblems() {
            const content = document.getElementById('subproblemsContent');
            const toggle = document.getElementById('subproblemsToggle');
            
            if (content.classList.contains('expanded')) {
                content.classList.remove('expanded');
                toggle.classList.remove('expanded');
                toggle.textContent = '‚ñ∂';
            } else {
                content.classList.add('expanded');
                toggle.classList.add('expanded');
                toggle.textContent = '‚ñº';
            }
        }

        function toggleSubproblemEdit(key) {
            const display = document.getElementById(`subproblemDisplay_${key}`);
            const rendered = document.getElementById(`subproblemRendered_${key}`);
            const edit = document.getElementById(`subproblemEdit_${key}`);
            
            if (display.style.display === 'none') {
                // Save and switch to display mode
                const newText = edit.querySelector('textarea').value;
                rendered.innerHTML = newText;
                display.style.display = 'block';
                edit.style.display = 'none';
                updateSubproblemText(key, newText);
                
                // Re-render LaTeX
                if (window.MathJax) {
                    MathJax.typesetPromise([rendered]);
                }
            } else {
                // Switch to edit mode
                display.style.display = 'none';
                edit.style.display = 'flex';
                const textarea = edit.querySelector('textarea');
                textarea.focus();
                autoResizeTextarea(textarea);
            }
        }

        function saveSubproblem(key) {
            toggleSubproblemEdit(key);
        }

        function toggleSubproblemAnswerEdit(key) {
            const display = document.getElementById(`subproblemAnswerDisplay_${key}`);
            const rendered = document.getElementById(`subproblemAnswerRendered_${key}`);
            const edit = document.getElementById(`subproblemAnswerEdit_${key}`);
            
            if (display.style.display === 'none') {
                // Save and switch to display mode
                const newText = edit.querySelector('textarea').value;
                rendered.innerHTML = newText;
                display.style.display = 'block';
                edit.style.display = 'none';
                updateSubproblemAnswer(key, newText);
                
                // Re-render LaTeX
                if (window.MathJax) {
                    MathJax.typesetPromise([rendered]);
                }
            } else {
                // Switch to edit mode
                display.style.display = 'none';
                edit.style.display = 'flex';
                const textarea = edit.querySelector('textarea');
                textarea.focus();
                autoResizeTextarea(textarea);
            }
        }

        function saveSubproblemAnswer(key) {
            toggleSubproblemAnswerEdit(key);
        }

        function toggleSubproblemSolutionEdit(key) {
            const display = document.getElementById(`subproblemSolutionDisplay_${key}`);
            const rendered = document.getElementById(`subproblemSolutionRendered_${key}`);
            const edit = document.getElementById(`subproblemSolutionEdit_${key}`);
            
            if (display.style.display === 'none') {
                // Save and switch to display mode
                const newText = edit.querySelector('textarea').value;
                rendered.innerHTML = newText;
                display.style.display = 'block';
                edit.style.display = 'none';
                updateSubproblemSolution(key, newText);
                
                // Re-render LaTeX
                if (window.MathJax) {
                    MathJax.typesetPromise([rendered]);
                }
            } else {
                // Switch to edit mode
                display.style.display = 'none';
                edit.style.display = 'flex';
                const textarea = edit.querySelector('textarea');
                textarea.focus();
                autoResizeTextarea(textarea);
            }
        }

        function saveSubproblemSolution(key) {
            toggleSubproblemSolutionEdit(key);
        }

        function updateSubproblemText(key, value) {
            if (currentProblemIndex >= 0) {
                if (!problemsData.problems[currentProblemIndex].subproblems) {
                    problemsData.problems[currentProblemIndex].subproblems = {};
                }
                if (!problemsData.problems[currentProblemIndex].subproblems[key]) {
                    problemsData.problems[currentProblemIndex].subproblems[key] = {
                        problem_text: null,
                        correct_answer: null,
                        solution: null,
                        images: []
                    };
                }
                problemsData.problems[currentProblemIndex].subproblems[key].problem_text = value;
            }
        }

        function updateSubproblemAnswer(key, value) {
            if (currentProblemIndex >= 0) {
                if (!problemsData.problems[currentProblemIndex].subproblems) {
                    problemsData.problems[currentProblemIndex].subproblems = {};
                }
                if (!problemsData.problems[currentProblemIndex].subproblems[key]) {
                    problemsData.problems[currentProblemIndex].subproblems[key] = {
                        problem_text: null,
                        correct_answer: null,
                        solution: null,
                        images: []
                    };
                }
                problemsData.problems[currentProblemIndex].subproblems[key].correct_answer = value;
            }
        }

        function updateSubproblemSolution(key, value) {
            if (currentProblemIndex >= 0) {
                if (!problemsData.problems[currentProblemIndex].subproblems) {
                    problemsData.problems[currentProblemIndex].subproblems = {};
                }
                if (!problemsData.problems[currentProblemIndex].subproblems[key]) {
                    problemsData.problems[currentProblemIndex].subproblems[key] = {
                        problem_text: null,
                        correct_answer: null,
                        solution: null,
                        images: []
                    };
                }
                problemsData.problems[currentProblemIndex].subproblems[key].solution = value;
            }
        }

        function toggleDomain(domain) {
            if (currentProblemIndex >= 0) {
                if (!problemsData.problems[currentProblemIndex].domain) {
                    problemsData.problems[currentProblemIndex].domain = [];
                }
                
                const domains = problemsData.problems[currentProblemIndex].domain;
                const domainLower = domain.toLowerCase();
                const index = domains.indexOf(domainLower);
                
                if (index > -1) {
                    // Remove domain
                    domains.splice(index, 1);
                } else {
                    // Add domain in lowercase
                    domains.push(domainLower);
                }
                
                updateDomainButtons();
            }
        }

        function updateDomainButtons() {
            const domainButtons = document.getElementById('domainButtons');
            const domains = problemsData.problems[currentProblemIndex].domain || [];
            domainButtons.innerHTML = generateDomainButtons(domains);
        }

        function toggleApproach(approach) {
            if (currentProblemIndex >= 0) {
                if (!problemsData.problems[currentProblemIndex].math_approach) {
                    problemsData.problems[currentProblemIndex].math_approach = [];
                }
                
                const approaches = problemsData.problems[currentProblemIndex].math_approach;
                const approachLower = approach.toLowerCase();
                const index = approaches.indexOf(approachLower);
                
                if (index > -1) {
                    // Remove approach
                    approaches.splice(index, 1);
                } else {
                    // Add approach in lowercase
                    approaches.push(approachLower);
                }
                
                updateApproachButtons();
            }
        }

        function updateApproachButtons() {
            const approachButtons = document.getElementById('approachButtons');
            const approaches = problemsData.problems[currentProblemIndex].math_approach || [];
            approachButtons.innerHTML = generateApproachButtons(approaches);
        }

        function toggleReasoning(reasoning) {
            if (currentProblemIndex >= 0) {
                if (!problemsData.problems[currentProblemIndex].reasoning_type) {
                    problemsData.problems[currentProblemIndex].reasoning_type = [];
                }
                
                const reasonings = problemsData.problems[currentProblemIndex].reasoning_type;
                const reasoningLower = reasoning.toLowerCase();
                const index = reasonings.indexOf(reasoningLower);
                
                if (index > -1) {
                    // Remove reasoning
                    reasonings.splice(index, 1);
                } else {
                    // Add reasoning in lowercase
                    reasonings.push(reasoningLower);
                }
                
                updateReasoningButtons();
            }
        }

        function updateReasoningButtons() {
            const reasoningButtons = document.querySelector('.reasoning-buttons');
            const reasonings = problemsData.problems[currentProblemIndex].reasoning_type || [];
            reasoningButtons.innerHTML = generateReasoningButtons(reasonings);
        }


        function removeProblem() {
            if (currentProblemIndex >= 0 && confirm('Are you sure you want to remove this entire problem? This action cannot be undone.')) {
                // Remove the problem from the array
                problemsData.problems.splice(currentProblemIndex, 1);
                
                // Update localStorage
                localStorage.setItem('problemsData', JSON.stringify(problemsData));
                
                // Reload the problems list
                loadProblems();
                
                // Reset current index
                currentProblemIndex = -1;
                
                // Show no problem selected
                const editorPanel = document.querySelector('.editor-panel');
                editorPanel.innerHTML = `
                    <div id="noProblem" class="no-problem">
                        <h3>No Problem Selected</h3>
                        <p>Select a problem from the sidebar to start editing</p>
                    </div>
                `;
                
                showSuccess('Problem removed successfully!');
            }
        }

        function handleMultilineEdit(event) {
            if (event.key === 'Enter' && event.shiftKey) {
                // Allow line break with Shift+Enter
                return true;
            } else if (event.key === 'Enter' && !event.shiftKey) {
                // Prevent default Enter behavior and trigger blur to save
                event.preventDefault();
                event.target.blur();
            }
            
            // Auto-resize textarea
            autoResizeTextarea(event.target);
        }

        function autoResizeTextarea(textarea) {
            textarea.style.height = 'auto';
            textarea.style.height = Math.max(60, textarea.scrollHeight) + 'px';
        }

        function addSubproblem() {
            const keyInput = document.getElementById('newSubproblemKey');
            const key = keyInput.value.trim().toLowerCase();
            
            if (!key || !/^[a-z]$/.test(key)) {
                alert('Please enter a single letter (a-z) for the subproblem key.');
                return;
            }
            
            if (currentProblemIndex >= 0) {
                if (!problemsData.problems[currentProblemIndex].subproblems) {
                    problemsData.problems[currentProblemIndex].subproblems = {};
                }
                
                if (problemsData.problems[currentProblemIndex].subproblems[key]) {
                    alert(`Subproblem ${key} already exists.`);
                    return;
                }
                
                // Add new subproblem with new structure
                problemsData.problems[currentProblemIndex].subproblems[key] = {
                    problem_text: '',
                    correct_answer: null,
                    solution: null
                };
                
                // Clear input
                keyInput.value = '';
                
                // Refresh the subproblems section
                refreshSubproblemsSection();
            }
        }

        function removeSubproblem(key) {
            if (currentProblemIndex >= 0) {
                delete problemsData.problems[currentProblemIndex].subproblems[key];
                
                // Keep subproblems as empty dict if no subproblems left
                if (Object.keys(problemsData.problems[currentProblemIndex].subproblems).length === 0) {
                    problemsData.problems[currentProblemIndex].subproblems = {};
                }
                
                // Refresh the subproblems section
                refreshSubproblemsSection();
            }
        }

        function refreshSubproblemsSection() {
            const problem = problemsData.problems[currentProblemIndex];
            const subproblemsContainer = document.querySelector('.subproblems-container');
            if (subproblemsContainer) {
                subproblemsContainer.outerHTML = generateSubproblemsSection(problem.subproblems);
                
                // Re-render LaTeX for new subproblems
                if (window.MathJax && problem.subproblems) {
                    const elementsToRender = [];
                    Object.keys(problem.subproblems).forEach(key => {
                        const subproblemElement = document.getElementById(`subproblemRendered_${key}`);
                        const subproblemAnswerElement = document.getElementById(`subproblemAnswerRendered_${key}`);
                        const subproblemSolutionElement = document.getElementById(`subproblemSolutionRendered_${key}`);
                        if (subproblemElement) {
                            elementsToRender.push(subproblemElement);
                        }
                        if (subproblemAnswerElement) {
                            elementsToRender.push(subproblemAnswerElement);
                        }
                        if (subproblemSolutionElement) {
                            elementsToRender.push(subproblemSolutionElement);
                        }
                    });
                    if (elementsToRender.length > 0) {
                        MathJax.typesetPromise(elementsToRender);
                    }
                }
            }
        }

        function refreshImageSection() {
            const problem = problemsData.problems[currentProblemIndex];
            const imageContainer = document.getElementById('problemImage');
            if (imageContainer) {
                imageContainer.innerHTML = generateImageSection(problem.images);
            }
        }


        function saveCurrentProblem() {
            if (currentProblemIndex >= 0) {
                // Save to localStorage as backup
                localStorage.setItem('problemsData', JSON.stringify(problemsData));
                if (originalFileName) {
                    localStorage.setItem('originalFileName', originalFileName);
                }
                
                // Mark this problem as manually saved and update completion status
                problemsData.problems[currentProblemIndex].manually_saved = true;
                
                // Update the problem status in the sidebar
                updateProblemStatus();
                
                showSuccess('Problem saved successfully!');
            }
        }

        function updateProblemStatus() {
            if (currentProblemIndex >= 0) {
                const problem = problemsData.problems[currentProblemIndex];
                const isComplete = problem.manually_saved && isProblemComplete(problem);
                
                const problemItem = document.querySelectorAll('.problem-item')[currentProblemIndex];
                const statusElement = problemItem.querySelector('.problem-status');
                
                statusElement.className = `problem-status ${isComplete ? 'complete' : 'incomplete'}`;
                statusElement.textContent = ''; // No text, just icons
                
                updateStats();
            }
        }

        function isProblemComplete(problem) {
            // Check if either problem_text exists OR at least one subproblem exists
            const hasContent = problem.problem_text || 
                              (problem.subproblems && Object.keys(problem.subproblems).length > 0 && 
                               Object.values(problem.subproblems).some(sp => sp && sp.trim()));
            
            return hasContent &&
                   problem.correct_answer && 
                   problem.solution && 
                   problem.difficulty && 
                   problem.topics && 
                   problem.topics.length > 0 &&
                   problem.domain &&
                   problem.domain.length > 0;
                   // Note: math_approach and reasoning_type are now optional
        }

        function updateStats() {
            if (!problemsData) return;

            const total = problemsData.problems.length;
            const completed = problemsData.problems.filter(p => p.manually_saved && isProblemComplete(p)).length;
            const incomplete = total - completed;

            document.getElementById('totalProblems').textContent = total;
            document.getElementById('completedProblems').textContent = completed;
            document.getElementById('incompleteProblems').textContent = incomplete;
            document.getElementById('stats').style.display = 'flex';
        }

        function exportData() {
            if (!problemsData) {
                showError('No data to export. Please load a JSON file first.');
                return;
            }

            // Create a copy for export
            const exportData = JSON.parse(JSON.stringify(problemsData));
            
            // Update metadata for export
            if (exportData.doc) {
                // Set updated_at timestamp in Eastern timezone with yyyy-mm-dd format
                const now = new Date();
                const easternTime = new Date(now.toLocaleString('en-US', { timeZone: 'America/New_York' }));
                const year = easternTime.getFullYear();
                const month = String(easternTime.getMonth() + 1).padStart(2, '0');
                const day = String(easternTime.getDate()).padStart(2, '0');
                const hours = String(easternTime.getHours()).padStart(2, '0');
                const minutes = String(easternTime.getMinutes()).padStart(2, '0');
                const seconds = String(easternTime.getSeconds()).padStart(2, '0');
                exportData.doc.updated_at = `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
                
                // Increment version
                if (exportData.doc.version === 'raw') {
                    exportData.doc.version = 'v1';
                } else if (exportData.doc.version && exportData.doc.version.startsWith('v')) {
                    const currentVersion = parseInt(exportData.doc.version.substring(1));
                    if (!isNaN(currentVersion)) {
                        exportData.doc.version = `v${currentVersion + 1}`;
                    } else {
                        exportData.doc.version = 'v1';
                    }
                } else {
                    exportData.doc.version = 'v1';
                }
            }

            const dataStr = JSON.stringify(exportData, null, 2);
            const dataBlob = new Blob([dataStr], {type: 'application/json'});
            const url = URL.createObjectURL(dataBlob);
            
            // Create filename with version suffix using the input file name
            const baseFileName = originalFileName ? originalFileName.replace('.json', '') : 'problems';
            const version = exportData.doc && exportData.doc.version ? exportData.doc.version : 'v1';
            const exportFileName = `${baseFileName}_${version}.json`;
            
            const link = document.createElement('a');
            link.href = url;
            link.download = exportFileName;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);

            showSuccess(`Data exported successfully as ${exportFileName}!`);
        }

        function showError(message) {
            const errorDiv = document.createElement('div');
            errorDiv.className = 'error';
            errorDiv.textContent = message;
            document.querySelector('.container').insertBefore(errorDiv, document.querySelector('.main-content'));
            
            setTimeout(() => {
                errorDiv.remove();
            }, 5000);
        }

        function showSuccess(message) {
            const successDiv = document.createElement('div');
            successDiv.className = 'success';
            successDiv.textContent = message;
            document.querySelector('.container').insertBefore(successDiv, document.querySelector('.main-content'));
            
            setTimeout(() => {
                successDiv.remove();
            }, 3000);
        }

        // Don't auto-load previous session data on initial page load
        // Show clean boilerplate page instead
        window.addEventListener('load', function() {
            // Load topics data first
            loadTopics();
            // Clean start - no auto-loading of previous session
            console.log('Editor loaded - ready for new file upload');
        });

        // Auto-resize textareas on input
        document.addEventListener('input', function(event) {
            if (event.target.tagName === 'TEXTAREA') {
                autoResizeTextarea(event.target);
            }
        });
    </script>
</body>
</html> 